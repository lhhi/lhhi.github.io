<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>13_DAY</title>
    <link href="/2024/10/17/13-DAY/"/>
    <url>/2024/10/17/13-DAY/</url>
    
    <content type="html"><![CDATA[<h1 id="定时器-2"><a href="#定时器-2" class="headerlink" title="定时器(2)"></a>定时器(2)</h1><ol><li><p>调整缓冲区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs bash">void fifo32_init(struct FIFO32 *fifo, int size, int *buf)<br>/* FIFO缓冲区的初始化*/<br>&#123;<br>fifo-&gt;size = size;<br>fifo-&gt;buf = buf;<br>fifo-&gt;free = size; /*空*/<br>fifo-&gt;flags = 0;<br>fifo-&gt;p = 0; /*写入位置*/<br>fifo-&gt;q = 0; /*读取位置*/<br><span class="hljs-built_in">return</span>;<br>&#125;<br><br>int fifo32_put(struct FIFO32 *fifo, int data)<br>/*给FIFO发送数据并储存在FIFO中*/<br>&#123;<br><span class="hljs-keyword">if</span> (fifo-&gt;free == 0) &#123;<br>/*没有空余空间，溢出*/<br>fifo-&gt;flags |= FLAGS_OVERRUN;<br><span class="hljs-built_in">return</span> -1;<br>&#125;<br>fifo-&gt;buf[fifo-&gt;p] = data;<br>fifo-&gt;p++;<br><span class="hljs-keyword">if</span> (fifo-&gt;p == fifo-&gt;size) &#123;<br>fifo-&gt;p = 0;<br>&#125;<br>fifo-&gt;free--;<br><span class="hljs-built_in">return</span> 0;<br>&#125;<br><br>int fifo32_get(struct FIFO32 *fifo)<br>/*从FIFO取得一个数据*/<br>&#123;<br>int data;<br><span class="hljs-keyword">if</span> (fifo-&gt;free == fifo-&gt;size) &#123;<br>/*当缓冲区为空的情况下返回-1*/<br><span class="hljs-built_in">return</span> -1;<br>&#125;<br>data = fifo-&gt;buf[fifo-&gt;q];<br>fifo-&gt;q++;<br><span class="hljs-keyword">if</span> (fifo-&gt;q == fifo-&gt;size) &#123;<br>fifo-&gt;q = 0;<br>&#125;<br>fifo-&gt;free++;<br><span class="hljs-built_in">return</span> data;<br>&#125;<br><br>int fifo32_status(struct FIFO32 *fifo)<br>/*报告已经存储了多少数据*/<br>&#123;<br><span class="hljs-built_in">return</span> fifo-&gt;size - fifo-&gt;free;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>合为一个缓冲区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> (;;) &#123;<br>count++;<br>io_cli();<br><span class="hljs-keyword">if</span> (fifo32_status(&amp;fifo) == 0) &#123;<br>io_sti();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>i = fifo32_get(&amp;fifo);<br>io_sti();<br><span class="hljs-keyword">if</span> (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /* 键盘数据*/<br>sprintf(s, <span class="hljs-string">&quot;%02X&quot;</span>, i - 256);<br>putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; /* 鼠标数据*/<br><span class="hljs-keyword">if</span> (mouse_decode(&amp;mdec, i - 512) != 0) &#123;<br>/* 已经收集了3字节的数据，所以显示出来 */<br>sprintf(s, <span class="hljs-string">&quot;[lcr %4d %4d]&quot;</span>, mdec.x, mdec.y);<br><span class="hljs-keyword">if</span> ((mdec.btn &amp; <span class="hljs-number">0</span>x01) != <span class="hljs-number">0</span>) &#123;<br>s[<span class="hljs-number">1</span>] = &#x27;L&#x27;;<br>&#125;<br>if ((mdec.btn &amp; <span class="hljs-number">0</span>x02) != <span class="hljs-number">0</span>) &#123;<br>s[<span class="hljs-number">3</span>] = &#x27;R&#x27;;<br>&#125;<br>if ((mdec.btn &amp; <span class="hljs-number">0</span>x04) != <span class="hljs-number">0</span>) &#123;<br>s[<span class="hljs-number">2</span>] = &#x27;C&#x27;;<br>&#125;<br>putfonts8_asc_sht(sht_back, <span class="hljs-number">32</span>, <span class="hljs-number">16</span>, COL8_FFFFFF, COL8_008484, s, <span class="hljs-number">15</span>);<br>/* 移动光标 */<br>mx += mdec.x;<br>my += mdec.y;<br>if (mx &lt; <span class="hljs-number">0</span>) &#123;<br>mx = <span class="hljs-number">0</span>;<br>&#125;<br>if (my &lt; <span class="hljs-number">0</span>) &#123;<br>my = <span class="hljs-number">0</span>;<br>&#125;<br>if (mx &gt; binfo-&gt;scrnx - <span class="hljs-number">1</span>) &#123;<br>mx = binfo-&gt;scrnx - <span class="hljs-number">1</span>;<br>&#125;<br>if (my &gt; binfo-&gt;scrny - <span class="hljs-number">1</span>) &#123;<br>my = binfo-&gt;scrny - <span class="hljs-number">1</span>;<br>&#125;<br>sprintf(s, &quot;(%<span class="hljs-number">3</span>d, %<span class="hljs-number">3</span>d)&quot;, mx, my);<br>putfonts8_asc_sht(sht_back, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, COL8_FFFFFF, COL8_008484, s, <span class="hljs-number">10</span>);<br>sheet_slide(sht_mouse, mx, my);/* 包含sheet_refresh含sheet_refresh */<br>&#125;<br>&#125; else if (i == <span class="hljs-number">10</span>) &#123; /* <span class="hljs-number">10</span>秒定时器 */<br>putfonts8_asc_sht(sht_back, <span class="hljs-number">0</span>, <span class="hljs-number">64</span>, COL8_FFFFFF, COL8_008484, &quot;<span class="hljs-number">10</span>[sec]&quot;, <span class="hljs-number">7</span>);<br>sprintf(s, &quot;%<span class="hljs-number">010</span>d&quot;, count);<br>putfonts8_asc_sht(sht_win, <span class="hljs-number">40</span>, <span class="hljs-number">28</span>, COL8_000000, COL8_C6C6C6, s, <span class="hljs-number">10</span>);<br>&#125; else if (i == <span class="hljs-number">3</span>) &#123; /* <span class="hljs-number">3</span>秒定时器 */<br>putfonts8_asc_sht(sht_back, <span class="hljs-number">0</span>, <span class="hljs-number">80</span>, COL8_FFFFFF, COL8_008484, &quot;<span class="hljs-number">3</span>[sec]&quot;, <span class="hljs-number">6</span>);<br> count = <span class="hljs-number">0</span>; /* 开始测试 */<br>&#125; else if (i == <span class="hljs-number">1</span>) &#123; /* 光标用定时器*/<br>timer_init(timer3, &amp;fifo, <span class="hljs-number">0</span>); /* 下面是设定<span class="hljs-number">0</span> */<br>boxfill8(buf_back, binfo-&gt;scrnx, COL8_FFFFFF, <span class="hljs-number">8</span>, <span class="hljs-number">96</span>, <span class="hljs-number">15</span>, <span class="hljs-number">111</span>);<br>timer_settime(timer3, <span class="hljs-number">50</span>);<br>sheet_refresh(sht_back, <span class="hljs-number">8</span>, <span class="hljs-number">96</span>, <span class="hljs-number">16</span>, <span class="hljs-number">112</span>);<br>&#125; else if (i == <span class="hljs-number">0</span>) &#123; /* 光标用定时器 */<br>timer_init(timer3, &amp;fifo, <span class="hljs-number">1</span>); /* 下面是设定<span class="hljs-number">1</span> */<br>boxfill8(buf_back, binfo-&gt;scrnx, COL8_008484, <span class="hljs-number">8</span>, <span class="hljs-number">96</span>, <span class="hljs-number">15</span>, <span class="hljs-number">111</span>);<br>timer_settime(timer3, <span class="hljs-number">50</span>);<br>sheet_refresh(sht_back, <span class="hljs-number">8</span>, <span class="hljs-number">96</span>, <span class="hljs-number">16</span>, <span class="hljs-number">112</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>将timers数组改为链表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">struct TIMER &#123;<br>struct TIMER *next;<br>unsigned int <span class="hljs-built_in">timeout</span>, flags;<br>struct FIFO32 *fifo;<br>int data;<br>&#125;;<br>struct TIMERCTL &#123;<br>unsigned int count, next;<br>struct TIMER *t0;<br>struct TIMER timers0[MAX_TIMER];<br>&#125;;<br>extern struct TIMERCTL timerctl;<br><br></code></pre></td></tr></table></figure></li><li><p>哨兵</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs bash">void init_pit(void)<br>&#123;<br>int i;<br>struct TIMER *t;<br>io_out8(PIT_CTRL, 0x34);<br>io_out8(PIT_CNT0, 0x9c);<br>io_out8(PIT_CNT0, 0x2e);<br>timerctl.count = 0;<br><span class="hljs-keyword">for</span> (i = 0; i &lt; MAX_TIMER; i++) &#123;<br>timerctl.timers0[i].flags = 0; /* 没有使用 */<br>&#125;<br>t = timer_alloc(); /* 取得一个 */<br>t-&gt;<span class="hljs-built_in">timeout</span> = 0xffffffff;<br>t-&gt;flags = TIMER_FLAGS_USING;<br>t-&gt;next = 0; /* 末尾 */<br>timerctl.t0 = t; /* 因为现在只有哨兵，所以他就在最前面*/<br>timerctl.next = 0xffffffff; /* 因为只有哨兵，所以下一个超时时刻就是哨兵的时刻 */<br><span class="hljs-built_in">return</span>;<br>&#125;<br><br>void timer_settime(struct TIMER *timer, unsigned int <span class="hljs-built_in">timeout</span>)<br>&#123;<br>int e;<br>struct TIMER *t, *s;<br>timer-&gt;<span class="hljs-built_in">timeout</span> = <span class="hljs-built_in">timeout</span> + timerctl.count;<br>timer-&gt;flags = TIMER_FLAGS_USING;<br>e = io_load_eflags();<br>io_cli();<br>t = timerctl.t0;<br><span class="hljs-keyword">if</span> (timer-&gt;<span class="hljs-built_in">timeout</span> &lt;= t-&gt;<span class="hljs-built_in">timeout</span>) &#123;<br>/* 插入最前面的情况 */<br>timerctl.t0 = timer;<br>timer-&gt;next = t; /* 下面是设定t */<br>timerctl.next = timer-&gt;<span class="hljs-built_in">timeout</span>;<br>io_store_eflags(e);<br><span class="hljs-built_in">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (;;) &#123;<br>s = t;<br>t = t-&gt;next;<br><span class="hljs-keyword">if</span> (timer-&gt;<span class="hljs-built_in">timeout</span> &lt;= t-&gt;<span class="hljs-built_in">timeout</span>) &#123;<br>/* 插入s和t之间的情况 */<br>s-&gt;next = timer; /* s下一个是timer */<br>timer-&gt;next = t; /* timer的下一个是t */<br>io_store_eflags(e);<br><span class="hljs-built_in">return</span>;<br>&#125;<br>&#125;<br>&#125;<br><br>void inthandler20(int *esp)<br>&#123;<br>struct TIMER *timer;<br>io_out8(PIC0_OCW2, 0x60); /* 把IRQ-00接收信号结束的信息通知给PIC */<br>timerctl.count++;<br><span class="hljs-keyword">if</span> (timerctl.next &gt; timerctl.count) &#123;<br><span class="hljs-built_in">return</span>;<br>&#125;<br>timer = timerctl.t0; /* 首先把最前面的地址赋给timer */<br><span class="hljs-keyword">for</span> (;;) &#123;<br>/* 因为timers的定时器都处于运行状态，所以不确认flags */<br><span class="hljs-keyword">if</span> (timer-&gt;<span class="hljs-built_in">timeout</span> &gt; timerctl.count) &#123;<br><span class="hljs-built_in">break</span>;<br>&#125;<br>/* 超时 */<br>timer-&gt;flags = TIMER_FLAGS_ALLOC;<br>fifo32_put(timer-&gt;fifo, timer-&gt;data);<br>timer = timer-&gt;next; /* 将下一个定时器的地址赋给timer*/<br>&#125;<br>timerctl.t0 = timer;<br>timerctl.next = timer-&gt;<span class="hljs-built_in">timeout</span>;<br><span class="hljs-built_in">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>12_DAY</title>
    <link href="/2024/10/16/12-DAY/"/>
    <url>/2024/10/16/12-DAY/</url>
    
    <content type="html"><![CDATA[<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><ol><li><p>设定PIT(可编程定时器)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#define PIT_CTRL0x0043</span><br><span class="hljs-comment">#define PIT_CNT00x0040</span><br><br>struct TIMERCTL timerctl;<br><br><span class="hljs-comment">#define TIMER_FLAGS_ALLOC 1 /* 已配置状态 */</span><br><span class="hljs-comment">#define TIMER_FLAGS_USING 2 /* 定时器运行中 */</span><br><br>void init_pit(void)<br>&#123;<br>int i;<br>io_out8(PIT_CTRL, 0x34);<br>io_out8(PIT_CNT0, 0x9c);<br>io_out8(PIT_CNT0, 0x2e);<br>timerctl.count = 0;<br>timerctl.next = 0xffffffff; /* 因为最初没有正在运行的定时器 */<br>timerctl.using = 0;<br><span class="hljs-keyword">for</span> (i = 0; i &lt; MAX_TIMER; i++) &#123;<br>timerctl.timers0[i].flags = 0; /* 未使用 */<br>&#125;<br><span class="hljs-built_in">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>超时功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs bash">void timer_settime(struct TIMER *timer, unsigned int <span class="hljs-built_in">timeout</span>)<br>&#123;<br>int e, i, j;<br>timer-&gt;<span class="hljs-built_in">timeout</span> = <span class="hljs-built_in">timeout</span> + timerctl.count;<br>timer-&gt;flags = TIMER_FLAGS_USING;<br>e = io_load_eflags();<br>io_cli();<br>/* 搜索注册位置 */<br><span class="hljs-keyword">for</span> (i = 0; i &lt; timerctl.using; i++) &#123;<br><span class="hljs-keyword">if</span> (timerctl.timers[i]-&gt;<span class="hljs-built_in">timeout</span> &gt;= timer-&gt;<span class="hljs-built_in">timeout</span>) &#123;<br><span class="hljs-built_in">break</span>;<br>&#125;<br>&#125;//按超时时间排序<br>/* i号之后全部后移一位 */<br><span class="hljs-keyword">for</span> (j = timerctl.using; j &gt; i; j--) &#123;<br>timerctl.timers[j] = timerctl.timers[j - 1];<br>&#125;<br>timerctl.using++;<br>/* 插入到空位上 */<br>timerctl.timers[i] = timer;<br>timerctl.next = timerctl.timers[0]-&gt;<span class="hljs-built_in">timeout</span>;<br>io_store_eflags(e);<br><span class="hljs-built_in">return</span>;<br>&#125;<br><br>void inthandler20(int *esp)<br>&#123;<br>int i, j;<br>io_out8(PIC0_OCW2, 0x60); /* 把IRQ-00信号接收完了的信息通知给PIC */<br>timerctl.count++;<br><span class="hljs-keyword">if</span> (timerctl.next &gt; timerctl.count) &#123;<br><span class="hljs-built_in">return</span>; /* 还不到下一个时刻，所以结束*/<br>&#125;<br>timerctl.next = 0xffffffff;<br><span class="hljs-keyword">for</span> (i = 0; i &lt; timerctl.using; i++) &#123;<br>/* timers的定时器都处于动作中，所以不确认flags */<br><span class="hljs-keyword">if</span> (timerctl.timers[i]-&gt;<span class="hljs-built_in">timeout</span> &gt; timerctl.count) &#123;<br><span class="hljs-built_in">break</span>;<br>&#125;<br>/* 超时*/<br>timerctl.timers[i]-&gt;flags = TIMER_FLAGS_ALLOC;<br>fifo8_put(timerctl.timers[i]-&gt;fifo, timerctl.timers[i]-&gt;data);<br>&#125;<br>/* 正好有i个定时器超时了。其余的进行移位。 */<br>timerctl.using -= i;<br><span class="hljs-keyword">for</span> (j = 0; j &lt; timerctl.using; j++) &#123;<br>timerctl.timers[j] = timerctl.timers[i + j];<br>&#125;<br><span class="hljs-keyword">if</span> (timerctl.using &gt; 0) &#123;<br>timerctl.next = timerctl.timers[0]-&gt;<span class="hljs-built_in">timeout</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>timerctl.next = 0xffffffff;<br>&#125;<br><span class="hljs-built_in">return</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>11_DAY</title>
    <link href="/2024/10/15/11-DAY/"/>
    <url>/2024/10/15/11-DAY/</url>
    
    <content type="html"><![CDATA[<h1 id="制作窗口"><a href="#制作窗口" class="headerlink" title="制作窗口"></a>制作窗口</h1><ol><li><p>制作图层</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs bash">void make_window8(unsigned char *buf, int xsize, int ysize, char *title)<br>&#123;<br>static char closebtn[14][16] = &#123;<br><span class="hljs-string">&quot;OOOOOOOOOOOOOOO@&quot;</span>,<br><span class="hljs-string">&quot;OQQQQQQQQQQQQQ<span class="hljs-variable">$@</span>&quot;</span>,<br><span class="hljs-string">&quot;OQQQQQQQQQQQQQ<span class="hljs-variable">$@</span>&quot;</span>,<br><span class="hljs-string">&quot;OQQQ@@QQQQ@@QQ<span class="hljs-variable">$@</span>&quot;</span>,<br><span class="hljs-string">&quot;OQQQQ@@QQ@@QQQ<span class="hljs-variable">$@</span>&quot;</span>,<br><span class="hljs-string">&quot;OQQQQQ@@@@QQQQ<span class="hljs-variable">$@</span>&quot;</span>,<br><span class="hljs-string">&quot;OQQQQQQ@@QQQQQ<span class="hljs-variable">$@</span>&quot;</span>,<br><span class="hljs-string">&quot;OQQQQQ@@@@QQQQ<span class="hljs-variable">$@</span>&quot;</span>,<br><span class="hljs-string">&quot;OQQQQ@@QQ@@QQQ<span class="hljs-variable">$@</span>&quot;</span>,<br><span class="hljs-string">&quot;OQQQ@@QQQQ@@QQ<span class="hljs-variable">$@</span>&quot;</span>,<br><span class="hljs-string">&quot;OQQQQQQQQQQQQQ<span class="hljs-variable">$@</span>&quot;</span>,<br><span class="hljs-string">&quot;OQQQQQQQQQQQQQ<span class="hljs-variable">$@</span>&quot;</span>,<br><span class="hljs-string">&quot;O$$$$$$$$$$$$$<span class="hljs-variable">$@</span>&quot;</span>,<br><span class="hljs-string">&quot;@@@@@@@@@@@@@@@@&quot;</span><br>&#125;;<br><br>int x, y;<br>char c;<br>boxfill8(buf, xsize, COL8_C6C6C6, 0, 0, xsize - 1, 0 );<br>boxfill8(buf, xsize, COL8_FFFFFF, 1, 1, xsize - 2, 1 );<br>boxfill8(buf, xsize, COL8_C6C6C6, 0, 0, 0, ysize - 1);<br>boxfill8(buf, xsize, COL8_FFFFFF, 1, 1, 1, ysize - 2);<br>boxfill8(buf, xsize, COL8_848484, xsize - 2, 1, xsize - 2, ysize - 2);<br>boxfill8(buf, xsize, COL8_000000, xsize - 1, 0, xsize - 1, ysize - 1);<br>boxfill8(buf, xsize, COL8_C6C6C6, 2, 2, xsize - 3, ysize - 3);<br>boxfill8(buf, xsize, COL8_000084, 3, 3, xsize - 4, 20 );<br>boxfill8(buf, xsize, COL8_848484, 1, ysize - 2, xsize - 2, ysize - 2);<br>boxfill8(buf, xsize, COL8_000000, 0, ysize - 1, xsize - 1, ysize - 1);<br>putfonts8_asc(buf, xsize, 24, 4, COL8_FFFFFF, title);<br><br><span class="hljs-keyword">for</span> (y = 0; y &lt; 14; y++) &#123;<br><span class="hljs-keyword">for</span> (x = 0; x &lt; 16; x++) &#123;<br>c = closebtn[y][x];<br><span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;@&#x27;</span>) &#123;<br>c = COL8_000000;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;$&#x27;</span>) &#123;<br>c = COL8_848484;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>c = COL8_C6C6C6;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c = COL8_FFFFFF;<br>&#125;<br>buf[(5 + y) * xsize + (xsize - 21 + x)] = c;<br>&#125;<br>&#125;<br><span class="hljs-built_in">return</span>;<br>&#125;//绘制一个窗口图形<br></code></pre></td></tr></table></figure></li><li><p>完成窗口的初始化</p></li><li><p>消除闪烁</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash">//加快刷新<br>void sheet_refresh(struct SHEET *sht, int bx0, int by0, int bx1, int by1)<br>&#123;<br><span class="hljs-keyword">if</span> (sht-&gt;height &gt;= 0) &#123; /* 如果正在显示，则按新图层的信息刷新画面*/<br>sheet_refreshsub(sht-&gt;ctl, sht-&gt;vx0 + bx0, sht-&gt;vy0 + by0, sht-&gt;vx0 + bx1, sht-&gt;vy0 + by1, sht-&gt;height, sht-&gt;height);<br>&#125;<br><span class="hljs-built_in">return</span>;<br>&#125;<br>//对改变的图层进行刷新<br>void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0, int h1)<br>&#123;<br>int h, bx, by, vx, vy, bx0, by0, bx1, by1;<br>unsigned char *buf, *vram = ctl-&gt;vram, *map = ctl-&gt;map, sid;<br>struct SHEET *sht;<br><br>/* 如果refresh的范围超出了画面则修正 */<br><span class="hljs-keyword">if</span> (vx0 &lt; 0) &#123; vx0 = 0; &#125;<br><span class="hljs-keyword">if</span> (vy0 &lt; 0) &#123; vy0 = 0; &#125;<br><span class="hljs-keyword">if</span> (vx1 &gt; ctl-&gt;xsize) &#123; vx1 = ctl-&gt;xsize; &#125;<br><span class="hljs-keyword">if</span> (vy1 &gt; ctl-&gt;ysize) &#123; vy1 = ctl-&gt;ysize; &#125;<br><br><span class="hljs-keyword">for</span> (h = h0; h &lt;= ctl-&gt;top; h++) &#123;<br>sht = ctl-&gt;sheets[h];<br>buf = sht-&gt;buf;<br>sid = sht -ctl-&gt;sheets0;<br><br>/* 使用vx0～vy1，对bx0～by1进行倒推 */<br>bx0 = vx0 - sht-&gt;vx0;<br>by0 = vy0 - sht-&gt;vy0;<br>bx1 = vx1 - sht-&gt;vx0;<br>by1 = vy1 - sht-&gt;vy0;<br><span class="hljs-keyword">if</span> (bx0 &lt; 0) &#123; bx0 = 0; &#125; /* 处理刷新范围在图层外侧 */<br><span class="hljs-keyword">if</span> (by0 &lt; 0) &#123; by0 = 0; &#125;<br><span class="hljs-keyword">if</span> (bx1 &gt; sht-&gt;bxsize) &#123; bx1 = sht-&gt;bxsize; &#125; /* 应对不同的重叠方式 */<br><span class="hljs-keyword">if</span> (by1 &gt; sht-&gt;bysize) &#123; by1 = sht-&gt;bysize; &#125;<br><br><span class="hljs-keyword">for</span> (by = by0; by &lt; by1; by++) &#123;<br>vy = sht-&gt;vy0 + by;<br><span class="hljs-keyword">for</span> (bx = bx0; bx &lt; bx1; bx++) &#123;<br>vx = sht-&gt;vx0 + bx;<br><span class="hljs-keyword">if</span> (map[vy * ctl-&gt;xsize + vx] == sid) &#123;<br>vram[vy * ctl-&gt;xsize + vx] = buf[by * sht-&gt;bxsize + bx];<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>制作map</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">void sheet_refreshmap(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0)<br>&#123;<br>int h, bx, by, vx, vy, bx0, by0, bx1, by1;<br>unsigned char *buf, sid, *map = ctl-&gt;map;<br>struct SHEET *sht;<br><br><span class="hljs-keyword">if</span> (vx0 &lt; 0) &#123; vx0 = 0; &#125;<br><span class="hljs-keyword">if</span> (vy0 &lt; 0) &#123; vy0 = 0; &#125;<br><span class="hljs-keyword">if</span> (vx1 &gt; ctl-&gt;xsize) &#123; vx1 = ctl-&gt;xsize; &#125;<br><span class="hljs-keyword">if</span> (vy1 &gt; ctl-&gt;ysize) &#123; vy1 = ctl-&gt;ysize; &#125;<br><br><span class="hljs-keyword">for</span> (h = h0; h &lt;= ctl-&gt;top; h++) &#123;<br>sht = ctl-&gt;sheets[h];<br>sid = sht - ctl-&gt;sheets0; /* 将进行了减法计算的地址作为图层号码使用 */<br>buf = sht-&gt;buf;<br>bx0 = vx0 - sht-&gt;vx0;<br>by0 = vy0 - sht-&gt;vy0;<br>bx1 = vx1 - sht-&gt;vx0;<br>by1 = vy1 - sht-&gt;vy0;<br><span class="hljs-keyword">if</span> (bx0 &lt; 0) &#123; bx0 = 0; &#125;<br><span class="hljs-keyword">if</span> (by0 &lt; 0) &#123; by0 = 0; &#125;<br><span class="hljs-keyword">if</span> (bx1 &gt; sht-&gt;bxsize) &#123; bx1 = sht-&gt;bxsize; &#125;<br><span class="hljs-keyword">if</span> (by1 &gt; sht-&gt;bysize) &#123; by1 = sht-&gt;bysize; &#125;<br><br><span class="hljs-keyword">for</span> (by = by0; by &lt; by1; by++) &#123;<br>vy = sht-&gt;vy0 + by;<br><span class="hljs-keyword">for</span> (bx = bx0; bx &lt; bx1; bx++) &#123;<br>vx = sht-&gt;vx0 + bx;<br><span class="hljs-keyword">if</span> (buf[by * sht-&gt;bxsize + bx] != sht-&gt;col_inv) &#123;<br>map[vy * ctl-&gt;xsize + vx] = sid;<br>&#125;//除去<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10_DAY</title>
    <link href="/2024/10/14/10-DAY/"/>
    <url>/2024/10/14/10-DAY/</url>
    
    <content type="html"><![CDATA[<h1 id="图层叠加处理"><a href="#图层叠加处理" class="headerlink" title="图层叠加处理"></a>图层叠加处理</h1><ol><li><p>建立图层结构体</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#define MAX_SHEETS256</span><br><span class="hljs-comment">#define SHEET_USE  1</span><br><br>struct SHEET &#123;<br>unsigned char *buf;<br>int bxsize, bysize, vx0, vy0, col_inv, height, flags;<br>&#125;;<br><br>struct SHTCTL &#123;<br>unsigned char *vram;<br>int xsize, ysize, top;<br>struct SHEET *sheets[MAX_SHEETS];<br>struct SHEET sheets0[MAX_SHEETS];<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>初始化图层管理结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bahs">struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize)<br>&#123;<br>struct SHTCTL *ctl;<br>int i;<br>ctl = (struct SHTCTL *) memman_alloc_4k(memman, sizeof (struct SHTCTL));<br>if (ctl == 0) &#123;<br>goto err;<br>&#125;<br>ctl-&gt;vram = vram;<br>ctl-&gt;xsize = xsize;<br>ctl-&gt;ysize = ysize;<br>ctl-&gt;top = -1; /* 没有一张SHEET */<br>for (i = 0; i &lt; MAX_SHEETS; i++) &#123;<br>ctl-&gt;sheets0[i].flags = 0; /* 标记为未使用 */<br>&#125;<br>err:<br>return ctl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>获得新的图层</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">//只要将图层管理器中的未使用图层标记为使用即可<br>struct SHEET *sheet_alloc(struct SHTCTL *ctl)<br>&#123;<br>struct SHEET *sht;<br>int i;<br><span class="hljs-keyword">for</span> (i = 0; i &lt; MAX_SHEETS; i++) &#123;<br><span class="hljs-keyword">if</span> (ctl-&gt;sheets0[i].flags == 0) &#123;<br>sht = &amp;ctl-&gt;sheets0[i];<br>sht-&gt;flags = SHEET_USE; /* 标记为正在使用*/<br>sht-&gt;height = -1; /* 隐藏 */<br><span class="hljs-built_in">return</span> sht;<br>&#125;<br>&#125;<br><span class="hljs-built_in">return</span> 0;  /* 所有的SHEET都处于正在使用状态*/<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>初始化新图层</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">void sheet_setbuf(struct SHEET *sht, unsigned char *buf, int xsize, int ysize, int col_inv)<br>&#123;<br>sht-&gt;buf = buf;//为新图层设置地址(缓冲区)<br>sht-&gt;bxsize = xsize;<br>sht-&gt;bysize = ysize;<br>sht-&gt;col_inv = col_inv;<br><span class="hljs-built_in">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>设置图层的高度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs bash">void sheet_updown(struct SHTCTL *ctl, struct SHEET *sht, int height)<br>&#123;<br>int h, old = sht-&gt;height; /* 存储设置前的高度信息 */<br><span class="hljs-keyword">if</span> (height &gt; ctl-&gt;top + 1) &#123;<br>height = ctl-&gt;top + 1;<br>&#125;<br><span class="hljs-keyword">if</span> (height &lt; -1) &#123;<br>height = -1;<br>&#125;<br>sht-&gt;height = height;/* 设定高度 */<br><br>/* 下面主要是进行sheets[ ]的重新排列 */<br><span class="hljs-keyword">if</span> (old &gt; height) &#123; /* 比以前低 */<br><span class="hljs-keyword">if</span> (height &gt;= 0) &#123;<br>/* 把中间的往上提 */<br><span class="hljs-keyword">for</span> (h = old; h &gt; height; h--) &#123;<br>ctl-&gt;sheets[h] = ctl-&gt;sheets[h - 1];<br>ctl-&gt;sheets[h]-&gt;height = h;<br>&#125;<br>ctl-&gt;sheets[height] = sht;<br>&#125; <span class="hljs-keyword">else</span> &#123; /* 隐藏 */<br><span class="hljs-keyword">if</span> (ctl-&gt;top &gt; old) &#123;<br>/* 把上面的降下来 */<br><span class="hljs-keyword">for</span> (h = old; h &lt; ctl-&gt;top; h++) &#123;<br>ctl-&gt;sheets[h] = ctl-&gt;sheets[h + 1];<br>ctl-&gt;sheets[h]-&gt;height = h;<br>&#125;<br>&#125;<br>ctl-&gt;top--; /* 由于显示中的图层减少了一个，所以最上面的图层高度下降 */<br>&#125;<br>sheet_refreshsub(ctl, sht-&gt;vx0, sht-&gt;vy0, sht-&gt;vx0 + sht-&gt;bxsize, sht-&gt;vy0 + sht-&gt;bysize); /* 按新图层的信息重新绘制画面 */    <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (old &lt; height) &#123; /* 比以前高 */<br><span class="hljs-keyword">if</span> (old &gt;= 0) &#123;<br>/* 把中间的拉下去 */<br><span class="hljs-keyword">for</span> (h = old; h &lt; height; h++) &#123;<br>ctl-&gt;sheets[h] = ctl-&gt;sheets[h + 1];<br>ctl-&gt;sheets[h]-&gt;height = h;<br>&#125;<br>ctl-&gt;sheets[height] = sht;<br>&#125; <span class="hljs-keyword">else</span> &#123; /* 由隐藏状态转为显示状态 */<br>/* 将已在上面的提上来 */<br><span class="hljs-keyword">for</span> (h = ctl-&gt;top; h &gt;= height; h--) &#123;<br>ctl-&gt;sheets[h + 1] = ctl-&gt;sheets[h];<br>ctl-&gt;sheets[h + 1]-&gt;height = h + 1;<br>&#125;<br>ctl-&gt;sheets[height] = sht;<br>ctl-&gt;top++; /* 由于已显示的图层增加了1个，所以最上面的图层高度增加 */<br>&#125;<br>sheet_refreshsub(ctl, sht-&gt;vx0, sht-&gt;vy0, sht-&gt;vx0 + sht-&gt;bxsize, sht-&gt;vy0 + sht-&gt;bysize); /* 按新图层信息重新绘制画面 */<br>&#125;<br><span class="hljs-built_in">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>图层刷新(从低到高刷新,铺地毯一样)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">void sheet_refresh(struct SHICTL *ctl)&#123;<br>int h,bx,by,vx,vy;<br>//bufx,bufy;<br>unsigned char *buf, *vram =ctl-&gt;vram;<br>struct SHEET *sht;<br><span class="hljs-keyword">for</span>(h=0;h&lt;=ctl-&gt;top;h++)&#123;<br>sht=ctl-&gt;sheets[h];<br>buf=sht-&gt;buf;<br><span class="hljs-keyword">for</span>(by=0;by&lt;sht-&gt;bxsize;by++)&#123;<br>vy=sht-&gt;vy0+bx;<br><span class="hljs-keyword">for</span>(bx=0;bx&lt;sht-&gt;bxsize;bx++)&#123;<br>vx=sht-&gt;vx0+bx;<br>c=buf[by*sht-&gt;bxsize+bx];<br><span class="hljs-keyword">if</span>(c!=sht-&gt;col_inv)&#123;<br>vram[vy*ctl-&gt;xsize+vx]=c;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>7.图层移动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">void sheet_slide(struct SHTCTL *ctl,struct SHEET *sht,int vx0,int vy0)&#123;<br>sht-&gt;vx0=vx0;<br>sht-&gt;vy0=vy0;<br><span class="hljs-keyword">if</span>(sht-&gt;height&gt;=0)&#123;//正在显示,则刷新<br>sheet_refresh(ctl);<br>&#125;<br><span class="hljs-built_in">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>8.释放图层</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">void sheet_free(struct SHTCTL *ctl, struct SHEET *sht)<br>&#123;<br><span class="hljs-keyword">if</span> (sht-&gt;height &gt;= 0) &#123;<br>sheet_updown(ctl, sht, -1); /* 如果处于显示状态，则先设定为隐藏 */<br>&#125;<br>sht-&gt;flags = 0; /* <span class="hljs-string">&quot;未使用&quot;</span>标志 */<br><span class="hljs-built_in">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>9.刷新优化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs bash">void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1)<br>&#123;<br>int h, bx, by, vx, vy, bx0, by0, bx1, by1;<br>unsigned char *buf, c, *vram = ctl-&gt;vram;<br>struct SHEET *sht;<br><span class="hljs-keyword">for</span> (h = 0; h &lt;= ctl-&gt;top; h++) &#123;<br>sht = ctl-&gt;sheets[h];<br>buf = sht-&gt;buf;<br>/* 使用vx0～vy1，对bx0～by1进行倒推 */<br>bx0 = vx0 - sht-&gt;vx0;<br>by0 = vy0 - sht-&gt;vy0;<br>bx1 = vx1 - sht-&gt;vx0;<br>by1 = vy1 - sht-&gt;vy0;<br><span class="hljs-keyword">if</span> (bx0 &lt; 0) &#123; bx0 = 0; &#125; /* 处理刷新范围在图层外侧 */<br><span class="hljs-keyword">if</span> (by0 &lt; 0) &#123; by0 = 0; &#125;<br><span class="hljs-keyword">if</span> (bx1 &gt; sht-&gt;bxsize) &#123; bx1 = sht-&gt;bxsize; &#125; /* 应对不同的重叠方式 */<br><span class="hljs-keyword">if</span> (by1 &gt; sht-&gt;bysize) &#123; by1 = sht-&gt;bysize; &#125;<br><br><span class="hljs-keyword">for</span> (by = by0; by &lt; by1; by++) &#123;<br>vy = sht-&gt;vy0 + by;<br><span class="hljs-keyword">for</span> (bx = bx0; bx &lt; bx1; bx++) &#123;<br>vx = sht-&gt;vx0 + bx;<br>c = buf[by * sht-&gt;bxsize + bx];<br><span class="hljs-keyword">if</span> (c != sht-&gt;col_inv) &#123;<br>vram[vy * ctl-&gt;xsize + vx] = c;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">return</span>;<br>&#125;<br>这段代码是对之前函数 `sheet_refreshsub` 的改进版本，主要增加了对图层刷新范围的边界处理，并进行了部分逻辑优化，避免不必要的计算。<br><br><span class="hljs-comment">### 改进部分的解释：</span><br><br>1. **引入新的局部变量**：<br>   - `bx0, by0, bx1, by1`：这些变量用于计算当前图层中的有效刷新区域。通过倒推，将给定的屏幕刷新范围（`vx0` 到 `vx1` 和 `vy0` 到 `vy1`）转换成当前图层的像素范围（`bx0` 到 `bx1` 和 `by0` 到 `by1`）。<br><br>2. **边界条件处理**：<br>   - `<span class="hljs-keyword">if</span> (bx0 &lt; 0) &#123; bx0 = 0; &#125;` 和 `<span class="hljs-keyword">if</span> (by0 &lt; 0) &#123; by0 = 0; &#125;`：如果刷新区域的一部分在图层的左侧或上侧之外，这里将起始位置调整为0，避免访问图层缓冲区之外的内存。<br>   - `<span class="hljs-keyword">if</span> (bx1 &gt; sht-&gt;bxsize) &#123; bx1 = sht-&gt;bxsize; &#125;` 和 `<span class="hljs-keyword">if</span> (by1 &gt; sht-&gt;bysize) &#123; by1 = sht-&gt;bysize; &#125;`：如果刷新区域超出了图层的右侧或下侧，则限制最大刷新范围为图层的边界，避免超出图层尺寸。<br><br>3. **逐像素刷新**：<br>   - 循环体的结构保持不变，继续通过嵌套循环遍历每一个有效的像素（`bx`, `by`），并通过倒推计算出该像素在屏幕上的位置（`vx`, `vy`）。<br>   - 如果像素不是透明的（`c != sht-&gt;col_inv`），则将其写入视频内存 `vram` 中。<br><br><span class="hljs-comment">### 代码功能总结：</span><br>- 这段代码通过计算屏幕上的刷新区域并将其转换为每个图层的局部坐标，实现了对每个图层的有效刷新。<br>- 代码中的边界检查有效地处理了不同图层之间的重叠情况，避免了对图层外区域的访问，并确保每个图层的显示在给定的区域内得到正确更新。<br>  <br><span class="hljs-comment">### 改进的意义：</span><br>- **效率提升**：通过倒推计算刷新区域，减少了不必要的像素遍历，提高了效率。特别是在多个图层重叠的情况下，只有实际需要刷新的区域会被处理。<br>- **边界处理**：避免了越界访问，确保图层不会因坐标计算超出范围而引发错误。<br><br>总体上，这段代码在原来的基础上做了边界检测和优化处理，确保了图层的更新更为高效和安全。<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>09_DAY</title>
    <link href="/2024/10/13/09-DAY/"/>
    <url>/2024/10/13/09-DAY/</url>
    
    <content type="html"><![CDATA[<h1 id="内存容量检查"><a href="#内存容量检查" class="headerlink" title="内存容量检查"></a>内存容量检查</h1><ol><li><p>关闭缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash">unsigned int memtest(unsigned int start, unsigned int end) <br>&#123;<br>char flg486 = 0;<br>unsigned int eflg, cr0, i;<br><br>/* 确认CPU是386还是486以上的 */<br>eflg = io_load_eflags();<br>eflg |= EFLAGS_AC_BIT; /* AC-bit = 1 */<br>io_store_eflags(eflg);<br>eflg = io_load_eflags();<br><span class="hljs-keyword">if</span> ((eflg &amp; EFLAGS_AC_BIT) != <span class="hljs-number">0</span>) &#123;<br>/* 如果是<span class="hljs-number">386</span>，即使设定AC=<span class="hljs-number">1</span>，AC的值还会自动回到<span class="hljs-number">0</span> */<br>flg486 = <span class="hljs-number">1</span>;<br>&#125;<br><br>eflg &amp;= ~EFLAGS_AC_BIT; /* AC-bit = <span class="hljs-number">0</span> */<br>io_store_eflags(eflg);<br><br>if (flg486 != <span class="hljs-number">0</span>) &#123;<br>cr0 = load_cr0();<br>cr0 |= CR0_CACHE_DISABLE; /* 禁止缓存 */ <br>store_cr0(cr0);<br>&#125;<br><br>i = memtest_sub(start, end);<br><br>if (flg486 != <span class="hljs-number">0</span>) &#123;<br>cr0 = load_cr0();<br>cr0 &amp;= ~CR0_CACHE_DISABLE; /* 允许缓存 */<br>store_cr0(cr0);<br>&#125;<br>return i;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>检查内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">_memtest_sub:; unsigned int memtest_sub(unsigned int start, unsigned int end)<br>PUSHEDI; （由于还要使用EBX, ESI, EDI）<br>PUSHESI<br>PUSHEBX<br>MOVESI,0xaa55aa55; pat0 = 0xaa55aa55;<br>MOVEDI,0x55aa55aa; pat1 = 0x55aa55aa;<br>MOVEAX,[ESP+12+4]; i = start;<br>mts_loop:<br>MOVEBX,EAX<br>ADDEBX,0xffc; p = i + 0xffc;<br>MOVEDX,[EBX]; old = *p;<br>MOV[EBX],ESI; *p = pat0;<br>XORDWORD [EBX],0xffffffff; *p ^= 0xffffffff;<br>CMPEDI,[EBX]; <span class="hljs-keyword">if</span> (*p != pat1) goto fin;<br>JNEmts_fin<br>XORDWORD [EBX],0xffffffff; *p ^= 0xffffffff;<br>CMPESI,[EBX]; <span class="hljs-keyword">if</span> (*p != pat0) goto fin;<br>JNEmts_fin<br>MOV[EBX],EDX; *p = old;<br>ADDEAX,0x1000; i += 0x1000;<br>CMPEAX,[ESP+12+8]; <span class="hljs-keyword">if</span> (i &lt;= end) goto mts_loop;<br>JBEmts_loop<br>POPEBX<br>POPESI<br>POPEDI<br>RET<br>mts_fin:<br>MOV[EBX],EDX; *p = old;<br>POPEBX<br>POPESI<br>POPEDI<br>RET<br></code></pre></td></tr></table></figure><h1 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h1><ol><li><p>建列表记录可用内存的地址和大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#define MEMMAN_FREES 4090 /* 大约是32KB*/</span><br><br>struct FREEINFO &#123; /* 可用信息 */<br>unsigned int addr, size;<br>&#125;;<br>struct MEMMAN &#123; /* 内存管理 */<br>int frees, maxfrees, lostsize, losts;<br>struct FREEINFO free[MEMMAN_FREES];<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">void memman_init(struct MEMMAN *man)&#123;<br>man-&gt;frees = 0;    /* 可用信息数目 */<br>man-&gt;maxfrees = 0; /* 用于观察可用状况：frees的最大值 */<br>man-&gt;lostsize = 0; /* 释放失败的内存的大小总和 */<br>man-&gt;losts = 0;    /* 释放失败次数 */<br><span class="hljs-built_in">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分配内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">unsigned int memman_alloc(struct MEMMAN *man, unsigned int size)<br>/* 分配 */<br>&#123;<br>unsigned int i, a;<br><span class="hljs-keyword">for</span> (i = 0; i &lt; man-&gt;frees; i++) &#123;<br><span class="hljs-keyword">if</span> (man-&gt;free[i].size &gt;= size) &#123;<br>/* 找到了足够大的内存 */<br>a = man-&gt;free[i].addr;<br>man-&gt;free[i].addr += size;<br>man-&gt;free[i].size -= size;<br><span class="hljs-keyword">if</span> (man-&gt;free[i].size == 0) &#123;<br>/* 如果free[i]变成了0，就减掉一条可用信息 */<br>man-&gt;frees--;<br><span class="hljs-keyword">for</span> (; i &lt; man-&gt;frees; i++) &#123;<br>man-&gt;free[i] = man-&gt;free[i + 1]; /* 代入结构体 */<br>&#125;<br>&#125;<br><span class="hljs-built_in">return</span> a;<br>&#125;<br>&#125;<br><span class="hljs-built_in">return</span> 0; /* 没有可用空间 */<br>&#125;<br></code></pre></td></tr></table></figure><p>4.释放内存(在列表中增加一条可用内存)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs bash">int memman_free(struct MEMMAN *man, unsigned int addr, unsigned int size)<br>/* 释放 */<br>&#123;<br>int i, j;<br>/* 为便于归纳内存，将free[]按照addr的顺序排列 */<br>/* 所以，先决定应该放在哪里 */<br><span class="hljs-keyword">for</span> (i = 0; i &lt; man-&gt;frees; i++) &#123;<br><span class="hljs-keyword">if</span> (man-&gt;free[i].addr &gt; addr) &#123;<br><span class="hljs-built_in">break</span>;<br>&#125;<br>&#125;<br>/* free[i - 1].addr &lt; addr &lt; free[i].addr */<br><span class="hljs-keyword">if</span> (i &gt; 0) &#123;<br>/* 前面有可用内存 */<br><span class="hljs-keyword">if</span> (man-&gt;free[i - 1].addr + man-&gt;free[i - 1].size == addr) &#123;<br>/* 可以与前面的可用内存归纳到一起 */<br>man-&gt;free[i - 1].size += size;<br><span class="hljs-keyword">if</span> (i &lt; man-&gt;frees) &#123;<br>/* 后面也有 */<br><span class="hljs-keyword">if</span> (addr + size == man-&gt;free[i].addr) &#123;<br>/* 也可以与后面的可用内存归纳到一起 */<br>man-&gt;free[i - 1].size += man-&gt;free[i].size;<br>/* man-&gt;free[i]删除 */<br>/* free[i]变成0后归纳到前面去 */<br>man-&gt;frees--;<br><span class="hljs-keyword">for</span> (; i &lt; man-&gt;frees; i++) &#123;<br>man-&gt;free[i] = man-&gt;free[i + 1]; /* 结构体赋值 */<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">return</span> 0; /* 成功完成 */<br>&#125;<br>&#125;<br>/* 不能与前面的可用空间归纳到一起 */<br><span class="hljs-keyword">if</span> (i &lt; man-&gt;frees) &#123;<br>/* 后面还有 */<br><span class="hljs-keyword">if</span> (addr + size == man-&gt;free[i].addr) &#123;<br>/* 可以与后面的内容归纳到一起 */<br>man-&gt;free[i].addr = addr;<br>man-&gt;free[i].size += size;<br><span class="hljs-built_in">return</span> 0; /* 成功完成 */<br>&#125;<br>&#125;<br>/* 既不能与前面归纳到一起，也不能与后面归纳到一起 */<br><span class="hljs-keyword">if</span> (man-&gt;frees &lt; MEMMAN_FREES) &#123;<br>/* free[i]之后的，向后移动，腾出一点可用空间 */<br><span class="hljs-keyword">for</span> (j = man-&gt;frees; j &gt; i; j--) &#123;<br>man-&gt;free[j] = man-&gt;free[j - 1];<br>&#125;<br>man-&gt;frees++;<br><span class="hljs-keyword">if</span> (man-&gt;maxfrees &lt; man-&gt;frees) &#123;<br>man-&gt;maxfrees = man-&gt;frees; /* 更新最大值 */<br>&#125;<br>man-&gt;free[i].addr = addr;<br>man-&gt;free[i].size = size;<br><span class="hljs-built_in">return</span> 0; /* 成功完成 */<br>&#125;<br>/* 不能往后移动 */<br>man-&gt;losts++;<br>man-&gt;lostsize += size;<br><span class="hljs-built_in">return</span> -1; /* 失败 */<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>08_DAY</title>
    <link href="/2024/10/12/08-DAY/"/>
    <url>/2024/10/12/08-DAY/</url>
    
    <content type="html"><![CDATA[<h1 id="鼠标控制"><a href="#鼠标控制" class="headerlink" title="鼠标控制"></a>鼠标控制</h1><ol><li><p>接受鼠标数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs bash">int mouse_decode(struct MOUSE_DEC *mdec, unsigned char dat)&#123;<br><span class="hljs-keyword">if</span> (mdec-&gt;phase == 0) &#123;<br>/* 等待鼠标的0xfa的阶段 */<br><span class="hljs-keyword">if</span> (dat == 0xfa) &#123;<br>mdec-&gt;phase = 1;<br>&#125;        <br><span class="hljs-built_in">return</span> 0;<br>&#125;<br><span class="hljs-keyword">if</span> (mdec-&gt;phase == 1) &#123;<br>/* 等待鼠标第一字节的阶段 */<br>mdec-&gt;buf[0] = dat;<br>mdec-&gt;phase = 2;<br><span class="hljs-built_in">return</span> 0;<br>&#125;//在阶段 1，函数等待鼠标输入的第一个字节，这个字节包含以下信息：<br>1. 按钮状态（低 3 位）。<br>2. X 和 Y 轴移动的标志位（第 4 和第 5 位）。<br>3. 接收到该字节后，将其存储在缓冲区 mdec-&gt;buf[0] 中，并进入阶段 2。<br><span class="hljs-keyword">if</span> (mdec-&gt;phase == 2) &#123;<br>/* 等待鼠标第二字节的阶段 */<br>mdec-&gt;buf[1] = dat;<br>mdec-&gt;phase = 3;<br><span class="hljs-built_in">return</span> 0;<br>&#125;//第二字节代表鼠标在X轴上的偏移量<br><span class="hljs-keyword">if</span> (mdec-&gt;phase == 3) &#123;<br>/* 等待鼠标第二字节的阶段 */<br>mdec-&gt;buf[2] = dat;//y轴偏移量<br>mdec-&gt;phase = 1;//充值<br>mdec-&gt;btn = mdec-&gt;buf[0] &amp; 0x07;//低三位,按钮状态<br>mdec-&gt;x = mdec-&gt;buf[1];<br>mdec-&gt;y = mdec-&gt;buf[2];<br><span class="hljs-keyword">if</span> ((mdec-&gt;buf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0</span>x10) != <span class="hljs-number">0</span>) &#123;<br>mdec-&gt;x |= <span class="hljs-number">0</span>xffffff00;<br>&#125;<br>if ((mdec-&gt;buf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0</span>x20) != <span class="hljs-number">0</span>) &#123;<br>mdec-&gt;y |= <span class="hljs-number">0</span>xffffff00;<br>&#125;     <br>/* 鼠标的y方向与画面符号相反 */   <br>mdec-&gt;y = - mdec-&gt;y; <br>return <span class="hljs-number">1</span>;<br>&#125;//在接收到所有三个字节后，函数会进行如下操作：<br><span class="hljs-number">1</span>. 从第一个字节提取按钮状态（mdec-&gt;btn = mdec-&gt;buf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0</span>x07）。<br><span class="hljs-number">2</span>. 存储 X 轴和 Y 轴的移动量（mdec-&gt;x = mdec-&gt;buf[<span class="hljs-number">1</span>]，mdec-&gt;y = mdec-&gt;buf[<span class="hljs-number">2</span>]）。<br><span class="hljs-number">3</span>. 如果第 <span class="hljs-number">4</span> 位（X 轴符号位）被设置，表示 X 值为负数，需要符号扩展（mdec-&gt;x |=       <span class="hljs-number">0</span>xffffff00）。<br><span class="hljs-number">4</span>. 如果第 <span class="hljs-number">5</span> 位（Y 轴符号位）被设置，表示 Y 值为负数（mdec-&gt;y |= <span class="hljs-number">0</span>xffffff00）。<br>由于鼠标的 Y 轴方向和屏幕的 Y 轴方向相反，因此需要将 Y 轴的移动量取反（mdec-&gt;y = -mdec- &gt;y）。<br>/* 应该不可能到这里来 */<br>return -<span class="hljs-number">1</span>; <br>&#125;<br>//接受鼠标发来的三字节信息<br>//鼠标传递的 X 和 Y 移动数据通常是 <span class="hljs-number">8</span> 位的有符号数（范围是 -<span class="hljs-number">128</span> 到 <span class="hljs-number">127</span>）。为了将这些数据处理成 <span class="hljs-number">32</span> 位整数（系统处理可能更方便），需要符号扩展。如果数值是负数，则必须将高位填充为 <span class="hljs-number">1</span>，以保持符号正确。<br></code></pre></td></tr></table></figure></li><li><p>移动鼠标指针</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs bash"> /* 3字节都凑齐了，所以把它们显示出来*/<br>sprintf(s, <span class="hljs-string">&quot;[lcr %4d %4d]&quot;</span>, mdec.x, mdec.y);<br><span class="hljs-keyword">if</span> ((mdec.btn &amp; <span class="hljs-number">0</span>x01) != <span class="hljs-number">0</span>) &#123;<br>s[<span class="hljs-number">1</span>] = &#x27;L&#x27;;<br>&#125;<br>if ((mdec.btn &amp; <span class="hljs-number">0</span>x02) != <span class="hljs-number">0</span>) &#123;<br>s[<span class="hljs-number">3</span>] = &#x27;R&#x27;;<br>        &#125;<br>if ((mdec.btn &amp; <span class="hljs-number">0</span>x04) != <span class="hljs-number">0</span>) &#123;<br>s[<span class="hljs-number">2</span>] = &#x27;C&#x27;;<br>&#125;<br>boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, <span class="hljs-number">32</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span> + <span class="hljs-number">15</span> * <span class="hljs-number">8</span>         - <span class="hljs-number">1</span>, <span class="hljs-number">31</span>);<br>putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, <span class="hljs-number">32</span>, <span class="hljs-number">16</span>, COL8_FFFFFF, s);<br>/* 鼠标指针的移动 */<br>    boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, mx, my, mx + <span class="hljs-number">15</span>, my         + <span class="hljs-number">15</span>); /* 隐藏鼠标 */<br>mx += mdec.x;<br>my += mdec.y;<br>if (mx &lt; <span class="hljs-number">0</span>) &#123;<br>mx = <span class="hljs-number">0</span>;<br>&#125;<br>if (my &lt; <span class="hljs-number">0</span>) &#123;<br>my = <span class="hljs-number">0</span>;<br>&#125;<br>if (mx &gt; binfo-&gt;scrnx - <span class="hljs-number">16</span>) &#123;<br>mx = binfo-&gt;scrnx - <span class="hljs-number">16</span>;<br>&#125;<br>if (my &gt; binfo-&gt;scrny - <span class="hljs-number">16</span>) &#123;<br>my = binfo-&gt;scrny - <span class="hljs-number">16</span>;<br>&#125;<br>sprintf(s, &quot;(%<span class="hljs-number">3</span>d, %<span class="hljs-number">3</span>d)&quot;, mx, my);<br>boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">79</span>, <span class="hljs-number">15</span>); /* 隐藏坐标 */<br>putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, COL8_FFFFFF, s); /* 显示坐标 */<br>putblock8_8(binfo-&gt;vram, binfo-&gt;scrnx, <span class="hljs-number">16</span>, <span class="hljs-number">16</span>, mx, my, mcursor, <span class="hljs-number">16</span>); /* 描画鼠标 */<br>这段代码是一个用来处理鼠标输入并在屏幕上显示鼠标移动和按钮状态的功能。它依赖于之前的 `mouse_decode` 函数，解码来自鼠标的<span class="hljs-number">3</span>字节数据，并根据鼠标的移动和按钮状态更新屏幕上的显示。下面是详细解析：<br><br>### 功能概述：<br><span class="hljs-number">1</span>. **处理鼠标数据并显示按钮状态：**<br>   - 使用 `mouse_decode(&amp;mdec, i)` 函数解析鼠标传入的数据 `i`，如果返回值不为 <span class="hljs-number">0</span>，表示鼠标的 <span class="hljs-number">3</span> 字节数据已经凑齐并可以进行处理。<br>   - 通过 `sprintf` 将鼠标的 X 和 Y 移动值和按钮状态显示在字符串 `s` 中。<br>   - 根据鼠标按钮的状态，修改字符串中的对应字符：<br>     - 如果左键按下（`btn &amp; <span class="hljs-number">0</span>x01`），把 `s[<span class="hljs-number">1</span>]` 改为 `L`。<br>     - 如果右键按下（`btn &amp; <span class="hljs-number">0</span>x02`），把 `s[<span class="hljs-number">3</span>]` 改为 `R`。<br>     - 如果中键按下（`btn &amp; <span class="hljs-number">0</span>x04`），把 `s[<span class="hljs-number">2</span>]` 改为 `C`。<br>   - 用 `boxfill8` 填充屏幕上的一块区域（擦除以前的显示），然后用 `putfonts8_asc` 在屏幕上显示处理好的字符串 `s`。<br><br><span class="hljs-number">2</span>. **更新鼠标指针的坐标：**<br>   - 使用 `mdec.x` 和 `mdec.y` 更新鼠标的 X 和 Y 位置：<br>     - 通过 `mx += mdec.x` 和 `my += mdec.y`，鼠标的坐标根据上一次的坐标移动。<br>   - 防止鼠标移出屏幕边界：<br>     - 如果 `mx` 小于 <span class="hljs-number">0</span>，设置 `mx = <span class="hljs-number">0</span>`；<br>     - 如果 `my` 小于 <span class="hljs-number">0</span>，设置 `my = <span class="hljs-number">0</span>`；<br>     - 如果 `mx` 超过屏幕宽度（`binfo-&gt;scrnx - <span class="hljs-number">16</span>`），设置 `mx` 为屏幕宽度减去鼠标指针的宽度；<br>     - 如果 `my` 超过屏幕高度（`binfo-&gt;scrny - <span class="hljs-number">16</span>`），设置 `my` 为屏幕高度减去鼠标指针的高度。<br><br><span class="hljs-number">3</span>. **显示鼠标的坐标：**<br>   - 用 `sprintf` 将更新后的鼠标坐标 `(mx, my)` 转换为字符串并显示在屏幕左上角。<br>   - 通过 `boxfill8` 填充屏幕左上角（隐藏旧的坐标），然后用 `putfonts8_asc` 在屏幕上显示新的坐标。<br><br><span class="hljs-number">4</span>. **重新绘制鼠标指针：**<br>   - 使用 `boxfill8` 隐藏原来的鼠标指针，避免旧指针残留在屏幕上。<br>   - 使用 `putblock8_8` 将新的鼠标指针绘制到新的 `(mx, my)` 位置。<br><br>### 核心功能：<br>- **鼠标按钮显示**：显示鼠标的左、中、右按钮状态。<br>- **鼠标移动**：根据鼠标输入的数据更新鼠标在屏幕上的位置，并处理边界情况。<br>- **坐标显示**：实时更新鼠标的 X、Y 坐标并显示在屏幕上。<br>- **指针绘制**：隐藏旧的鼠标指针，重新在新的位置绘制鼠标指针。<br><br>### 关键代码解析：<br>- `mouse_decode(&amp;mdec, i)`：调用鼠标解码函数，如果成功解析到 <span class="hljs-number">3</span> 字节的鼠标数据，则返回非 <span class="hljs-number">0</span> 值。<br>- `sprintf(s, &quot;[lcr %<span class="hljs-number">4</span>d %<span class="hljs-number">4</span>d]&quot;, mdec.x, mdec.y)`：将 X 和 Y 坐标及按钮状态格式化到字符串 `s` 中。<br>- `mx += mdec.x; my += mdec.y;`：根据鼠标的 X 和 Y 变化更新鼠标的当前位置。<br>- `putblock8_8(...)`：在屏幕的 `(mx, my)` 位置绘制鼠标指针。<br><br>这一段代码的作用是实现一个基本的鼠标移动跟踪，并将鼠标移动和点击状态显示在屏幕上，属于操作系统或嵌入式系统中简单的图形界面部分。<br></code></pre></td></tr></table></figure><h1 id="进入32位模式"><a href="#进入32位模式" class="headerlink" title="进入32位模式"></a>进入32位模式</h1><ol><li><p>关闭中断</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">;PIC关闭一切中断<br>;根据AT兼容机的规格，如果要初始化PIC，<br>;必须在CLI之前进行，否则有时会挂起。<br>;随后进行PIC的初始化。<br><br>MOVAL,0xff<br>OUT0x21,AL<br>NOP; 如果连续执行OUT指令，有些机种会无法正常运行<br>OUT0xa1,AL<br><br>CLI; 禁止CPU级别的中断<br></code></pre></td></tr></table></figure></li><li><p>开启A20信号线,使cpu能访问1MB以上的内容.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">;为了让CPU能够访问1MB以上的内存空间，设定A20GATE<br><br>CALLwaitkbdout<br>MOVAL,0xd1<br>OUT0x64,AL<br>CALLwaitkbdout<br>MOVAL,0xdf; <span class="hljs-built_in">enable</span> A20<br>OUT0x60,AL<br>CALLwaitkbdout<br><br></code></pre></td></tr></table></figure></li><li><p>切换到保护模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">[INSTRSET <span class="hljs-string">&quot;i486p&quot;</span>]; 说明使用486指令<br><br>LGDT[GDTR0]; 设置临时GDT<br>MOVEAX,CR0<br>ANDEAX,0x7fffffff; 设bit31为0（禁用分页）<br>OREAX,0x00000001; bit0到1转换（保护模式过渡）<br>MOVCR0,EAX<br>JMPpipelineflush<br>pipelineflush:<br>MOVAX,1*8;  可读写的段 32bit<br>MOVDS,AX<br>MOVES,AX<br>MOVFS,AX<br>MOVGS,AX<br>MOVSS,AX<br>切换模式后,要刷新流水线<br></code></pre></td></tr></table></figure></li><li><p>bookpack内容传送</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">; bootpack传递<br><br>MOVESI,bootpack; 转送源<br>MOVEDI,BOTPAK; 转送目标<br>MOVECX,512*1024/4<br>CALLmemcpy<br><br>; 磁盘数据最终转送到它本来的位置去<br>; 首先从启动扇区开始<br><br>MOVESI,0x7c00; 转送源<br>MOVEDI,DSKCAC; 转送目标<br>MOVECX,512/4<br>CALLmemcpy<br><br>; 剩余的全部<br><br>MOVESI,DSKCAC0+512; 转送源<br>MOVEDI,DSKCAC+512; 转送源目标<br>MOVECX,0<br>MOVCL,BYTE [CYLS]<br>IMULECX,512*18*2/4; 从柱面数变换为字节数/4<br>SUBECX,512/4; 减去 IPL 偏移量<br>CALLmemcpy<br><br>; 必须由asmhead来完成的工作，至此全部完毕<br>; 以后就交由bootpack来完成<br></code></pre></td></tr></table></figure></li><li><p>bookpack启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs bash">; bootpack启动<br><br>MOVEBX,BOTPAK<br>MOVECX,[EBX+16]<br>ADDECX,3; ECX += 3;<br>SHRECX,2; ECX /= 4;<br>JZskip; 没有要转送的东西时<br>MOVESI,[EBX+20]; 转送源<br>ADDESI,EBX<br>MOVEDI,[EBX+12]; 转送目标<br>CALLmemcpy<br>skip:<br>MOVESP,[EBX+12]; 堆栈的初始化<br>JMPDWORD 2*8:0x0000001b<br><br>这段汇编代码实现了 `bootpack` 启动时的部分功能，包括数据的转送和堆栈初始化。以下是代码逐步的详细分析：<br><br><span class="hljs-comment">### 代码功能概述：</span><br><br>1. **转送数据到指定目标地址**：<br>   - 计算需要转送的数据大小。<br>   - 如果有数据要转送，则调用 `memcpy` 函数，将数据从源地址复制到目标地址。<br><br>2. **初始化堆栈指针 (`ESP`)**：<br>   - 设置堆栈指针，准备跳转到程序的执行地址。<br><br>3. **跳转到指定位置执行**：<br>   - 跳转到程序入口地址 `0x0000001b`，开始执行主程序。<br><br><span class="hljs-comment">### 逐步解析：</span><br><br>```asm<br>MOV     EBX,BOTPAK<br>```<br>- 将 `BOTPAK` 的地址存入 `EBX`，`BOTPAK` 是程序或数据包的起始地址。<br><br>```asm<br>MOV     ECX,[EBX+16]<br>ADD     ECX,3          ; ECX += 3;<br>SHR     ECX,2          ; ECX /= 4;<br>```<br>- 这段代码的目的是计算要转送的数据大小。<br>- `MOV ECX,[EBX+16]`：从 `EBX` 地址偏移 16 字节处（可能是数据长度字段）加载数据大小到 `ECX`。<br>- `ADD ECX,3`：为了保证数据是以 4 字节对齐，所以先将 `ECX` 增加 3，保证数据向上取整。<br>- `SHR ECX,2`：将 `ECX` 右移 2 位，即除以 4，将字节数转换为 4 字节的单位。<br><br>```asm<br>JZ      skip<br>```<br>- 检查 `ECX` 是否为 0，如果为 0 则表示没有数据需要转送，跳转到 `skip` 标签处，跳过数据转送部分。<br><br>```asm<br>MOV     ESI,[EBX+20]    ; 转送源<br>ADD     ESI,EBX<br>MOV     EDI,[EBX+12]    ; 转送目标<br>CALL    memcpy<br>```<br>- 开始进行数据的转送操作：<br>  - `MOV ESI,[EBX+20]`：从 `EBX` 地址偏移 20 字节处读取源地址，并存入 `ESI`（源地址寄存器）。<br>  - `ADD ESI,EBX`：将源地址加上 `EBX`，得到源数据的实际地址。<br>  - `MOV EDI,[EBX+12]`：从 `EBX` 地址偏移 12 字节处读取目标地址，并存入 `EDI`（目标地址寄存器）。<br>  - `CALL memcpy`：调用 `memcpy` 函数，将数据从 `ESI` 指向的源地址复制到 `EDI` 指向的目标地址。<br><br>```asm<br>skip:<br>MOV     ESP,[EBX+12]    ; 堆栈的初始化<br>```<br>- 初始化堆栈指针：<br>  - `MOV ESP,[EBX+12]`：从 `EBX` 地址偏移 12 字节处读取堆栈指针的初始值，并将其赋值给 `ESP`，这将堆栈初始化为正确的值。<br><br>```asm<br>JMP     DWORD 2*8:0x0000001b<br>```<br>- 跳转到程序的入口地址：<br>  - 通过 `JMP DWORD 2*8:0x0000001b` 语句进行远程跳转。这里的 `2*8` 表示使用段选择子 2 的 8 字节倍数（也就是段选择子 16），`0x0000001b` 是目标偏移地址，表示跳转到物理地址 `0x0000001b` 开始执行程序。<br><br><span class="hljs-comment">### 总结：</span><br>这段代码的主要作用是：<br>1. **数据搬移**：根据从 `BOTPAK` 处读取的元数据，判断是否需要转送某段数据。如果需要，将数据从源地址复制到目标地址。<br>2. **堆栈初始化**：设置堆栈指针，以便程序能够正确使用堆栈。<br>3. **跳转到程序入口**：最终跳转到指定的程序入口地址，开始执行程序。<br><br>这段代码通常出现在一个启动加载程序中，在系统启动时，将内存中的某些数据搬移到正确的地方，并且初始化堆栈，最后跳转到内核或主程序的入口处。<br></code></pre></td></tr></table></figure></li><li><p>内存分布图</p><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20241012211859799.png" alt="image-20241012211859799">7.一些函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">waitkbdout:<br>INAL,0x64<br>ANDAL,0x02<br>INAL,0x60; 空读（为了清空数据接收缓冲区中的垃圾数据）<br>JNZwaitkbdout; AND的结果如果不是0，就跳到waitkbdout<br>RET<br><br>memcpy:<br>MOVEAX,[ESI]<br>ADDESI,4<br>MOV[EDI],EAX<br>ADDEDI,4<br>SUBECX,1<br>JNZmemcpy; 减法运算的结果如果不是0，就跳转到memcpy<br>RET<br>; memcpy地址前缀大小<br><br>ALIGNB16<br>GDT0:<br>RESB8; 初始值<br>DW0xffff,0x0000,0x9200,0x00cf; 可以读写的段（segment）32bit<br>DW0xffff,0x0000,0x9a28,0x0047; 可执行的文件的32bit寄存器（bootpack用）<br><br>DW0<br>GDTR0:<br>DW8*3-1<br>DDGDT0<br><br>ALIGNB16<br>bootpack:<br></code></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>07_DAy</title>
    <link href="/2024/10/11/07-DAy/"/>
    <url>/2024/10/11/07-DAy/</url>
    
    <content type="html"><![CDATA[<h1 id="FIFO-队列-缓冲区"><a href="#FIFO-队列-缓冲区" class="headerlink" title="FIFO(队列)缓冲区"></a>FIFO(队列)缓冲区</h1><ol><li><pre><code class="bash">    struct BOOTINFO *binfo = (struct BOOTINFO *) ADR_BOOTINFO;    unsigned char data, s[4];    io_out8(PIC0_OCW2, 0x61);/* 通知PIC IRQ-01 已经受理完毕 */    data = io_in8(PORT_KEYDAT);//从键盘接受数据,端口号为0x0060<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-number">2.</span> ```<span class="hljs-function">bash</span><br><span class="hljs-function">   <span class="hljs-type">void</span> <span class="hljs-title">inthandler21</span><span class="hljs-params">(<span class="hljs-type">int</span> *esp)</span></span><br><span class="hljs-function">   <span class="hljs-comment">/* 来自PS/2键盘的中断 */</span></span><br><span class="hljs-function">   </span>&#123;<br>   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BOOTINFO</span> *binfo = (<span class="hljs-keyword">struct</span> BOOTINFO *) ADR_BOOTINFO;<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data, s[<span class="hljs-number">4</span>];<br>   <span class="hljs-built_in">io_out8</span>(PIC0_OCW2, <span class="hljs-number">0x61</span>);<span class="hljs-comment">/* 通知PIC IRQ-01 已经受理完毕 */</span><br>   data = <span class="hljs-built_in">io_in8</span>(PORT_KEYDAT);<br>   <span class="hljs-built_in">fifo8_put</span>(&amp;keyfifo, data);/将数据存入缓冲区<br>   <span class="hljs-keyword">return</span>;<br>   &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="bash">for (;;) &#123;    io_cli();//关中断    if (fifo8_status(&amp;keyfifo) + fifo8_status(&amp;mousefifo) == 0) &#123;        io_stihlt();//恢复中断并进入hlt    &#125; else &#123;        if (fifo8_status(&amp;keyfifo) != 0) &#123;            i = fifo8_get(&amp;keyfifo);//pop()            io_sti();            sprintf(s, &quot;%02X&quot;, i);            boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484,  0, 16, 15, 31);            putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 0, 16, COL8_FFFFFF, s);        &#125; else if (fifo8_status(&amp;mousefifo) != 0) &#123;            i = fifo8_get(&amp;mousefifo);//pop()            io_sti();            sprintf(s, &quot;%02X&quot;, i);            boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, 32, 16, 47, 31);            putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 32, 16, COL8_FFFFFF, s);        &#125;    &#125;&#125;//检查缓冲区是否有元素,有则输出<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs xl"><br><span class="hljs-number">4</span>. ```bash<br>   <span class="hljs-comment">//循环队列的基本操作</span><br>   struct FIFO8 &#123;<br>   unsigned char *buf;<br>   int p, q, size, free, flags;<br>   &#125;;<span class="hljs-comment">//结构定义</span><br>   <br>   void fifo8_init(struct FIFO8 *fifo, int size, unsigned char *buf)<br>   <span class="hljs-comment">/* 初始化FIFO缓冲区 */</span><br>   &#123;<br>   <span class="hljs-function"><span class="hljs-title">fifo</span>-&gt;</span>size = size;<br>   <span class="hljs-function"><span class="hljs-title">fifo</span>-&gt;</span>buf = buf;<br>   <span class="hljs-function"><span class="hljs-title">fifo</span>-&gt;</span>free = size; <span class="hljs-comment">/* 缓冲区大小 */</span><br>   <span class="hljs-function"><span class="hljs-title">fifo</span>-&gt;</span>flags = <span class="hljs-number">0</span>;<br>   <span class="hljs-function"><span class="hljs-title">fifo</span>-&gt;</span>p = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 下一个数据写入位置 */</span><br>   <span class="hljs-function"><span class="hljs-title">fifo</span>-&gt;</span>q = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 下一个数据读出位置 */</span><br>   return;<br>   &#125;<span class="hljs-comment">//初始化</span><br>   <br>   int fifo8_put(struct FIFO8 *fifo, unsigned char <span class="hljs-keyword">data</span>)<br>   <span class="hljs-comment">/* 向FIFO传送数据并保存 */</span><br>   &#123;<br>   <span class="hljs-function"><span class="hljs-title">if</span> (fifo-&gt;</span>free == <span class="hljs-number">0</span>) &#123;<br>   <span class="hljs-comment">/* 没有空间了，溢出 */</span><br>   <span class="hljs-function"><span class="hljs-title">fifo</span>-&gt;</span>flags |= FLAGS_OVERRUN;<br>   return -<span class="hljs-number">1</span>;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-title">fifo</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">buf</span>[fifo-&gt;</span>p] = <span class="hljs-keyword">data</span>;<br>   <span class="hljs-function"><span class="hljs-title">fifo</span>-&gt;</span>p++;<br>   <span class="hljs-function"><span class="hljs-title">if</span> (fifo-&gt;</span><span class="hljs-function"><span class="hljs-title">p</span> == fifo-&gt;</span>size) &#123;<br>   <span class="hljs-function"><span class="hljs-title">fifo</span>-&gt;</span>p = <span class="hljs-number">0</span>;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-title">fifo</span>-&gt;</span>free--;<br>   return <span class="hljs-number">0</span>;<br>   &#125;<span class="hljs-comment">//push</span><br>   <br>   int fifo8_get(struct FIFO8 *fifo)<br>   <span class="hljs-comment">/* 从FIFO取得一个数据 */</span><br>   &#123;<br>   int <span class="hljs-keyword">data</span>;<br>   <span class="hljs-function"><span class="hljs-title">if</span> (fifo-&gt;</span><span class="hljs-function"><span class="hljs-title">free</span> == fifo-&gt;</span>size) &#123;<br>   <span class="hljs-comment">/* 如果缓冲区为空则返回-1 */</span><br>   return -<span class="hljs-number">1</span>;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-title">data</span> = fifo-&gt;</span><span class="hljs-function"><span class="hljs-title">buf</span>[fifo-&gt;</span>q];<br>   <span class="hljs-function"><span class="hljs-title">fifo</span>-&gt;</span>q++;<br>   <span class="hljs-function"><span class="hljs-title">if</span> (fifo-&gt;</span><span class="hljs-function"><span class="hljs-title">q</span> == fifo-&gt;</span>size) &#123;<br>   <span class="hljs-function"><span class="hljs-title">fifo</span>-&gt;</span>q = <span class="hljs-number">0</span>;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-title">fifo</span>-&gt;</span>free++;<br>   return <span class="hljs-keyword">data</span>;<br>   &#125;<span class="hljs-comment">//pop()</span><br>   <br>   int fifo8_status(struct FIFO8 *fifo)<br>   <span class="hljs-comment">/* 报告一下积攒是数据量 */</span><br>   &#123;<br>   <span class="hljs-function"><span class="hljs-title">return</span> fifo-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span> - fifo-&gt;</span>free;<br>   &#125;<span class="hljs-comment">//IsFull</span><br>   <br></code></pre></td></tr></table></figure># 鼠标的激活1. ```bash   void wait_KBC_sendready(void)   &#123;       /* 等待键盘控制电路准备完毕 */       for (;;) &#123;           if ((io_in8(PORT_KEYSTA) &amp; KEYSTA_SEND_NOTREADY) == 0) &#123;               break;           &#125;       &#125;       return;   &#125;//鼠标的控制电路在键盘的控制电路中.   <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss"><br><span class="hljs-number">2</span>. ```bash<br>   void <span class="hljs-built_in">init_keyboard</span>(void)<br>   &#123;<br>   <span class="hljs-comment">/* 初始化键盘控制电路 */</span><br>   <span class="hljs-built_in">wait_KBC_sendready</span>();<br>   <span class="hljs-built_in">io_out8</span>(PORT_KEYCMD, KEYCMD_WRITE_MODE);<br>   <span class="hljs-built_in">wait_KBC_sendready</span>();<br>   <span class="hljs-built_in">io_out8</span>(PORT_KEYDAT, KBC_MODE);<br>   return;<br>   &#125;<span class="hljs-comment">//启用鼠标模式,激活控制电路</span><br></code></pre></td></tr></table></figure>3. ```bash   #define KEYCMD_SENDTO_MOUSE0xd4   #define MOUSECMD_ENABLE0xf4      void enable_mouse(void)   &#123;       /* 激活鼠标 */       wait_KBC_sendready();       io_out8(PORT_KEYCMD, KEYCMD_SENDTO_MOUSE);//向键盘控制器发送0xd4       wait_KBC_sendready();       io_out8(PORT_KEYDAT, MOUSECMD_ENABLE);       return; /* 顺利的话，键盘控制器会返回ACK(0xfa) */   &#125;//激活鼠标   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br># 鼠标中断处理程序<br><br>```bash<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FIFO8</span> mousefifo;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inthandler2c</span><span class="hljs-params">(<span class="hljs-type">int</span> *esp)</span></span><br><span class="hljs-function"><span class="hljs-comment">/* 来自PS/2鼠标的中断 */</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data;<br><span class="hljs-built_in">io_out8</span>(PIC1_OCW2, <span class="hljs-number">0x64</span>);<span class="hljs-comment">/* 通知PIC IRQ-12 已经受理完毕 */</span><br><span class="hljs-built_in">io_out8</span>(PIC0_OCW2, <span class="hljs-number">0x62</span>);<span class="hljs-comment">/* 通知PIC IRQ-02 已经受理完毕 */</span><br>data = <span class="hljs-built_in">io_in8</span>(PORT_KEYDAT);<span class="hljs-comment">//也是从键盘接受数据</span><br><span class="hljs-built_in">fifo8_put</span>(&amp;mousefifo, data);<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>   # 鼠标数据显示   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> (;;) &#123;<br>io_cli();<br><span class="hljs-keyword">if</span> (fifo8_status(&amp;keyfifo) + fifo8_status(&amp;mousefifo) == 0) &#123;<br>io_stihlt();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (fifo8_status(&amp;keyfifo) != 0) &#123;<br>i = fifo8_get(&amp;keyfifo);<br>io_sti();<br>sprintf(s, <span class="hljs-string">&quot;%02X&quot;</span>, i);<br>boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484,  0,16,15,31);<br>    putfonts8_asc(binfo-&gt;vram,binfo-&gt;scrnx, 0, 16, COL8_FFFFFF,s);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fifo8_status(&amp;mousefifo) != 0) &#123;<br>i = fifo8_get(&amp;mousefifo);<br>io_sti();<br>sprintf(s, <span class="hljs-string">&quot;%02X&quot;</span>, i);<br>boxfill8(binfo-&gt;vram,binfo-&gt;scrnx,COL8_008484,32, 16, 47, 31);<br>putfonts8_asc(binfo-&gt;vram,binfo-&gt;scrnx,32,16, COL8_FFFFFF, s);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>06_DAY</title>
    <link href="/2024/10/10/06-DAY/"/>
    <url>/2024/10/10/06-DAY/</url>
    
    <content type="html"><![CDATA[<h1 id="设置段描述符"><a href="#设置段描述符" class="headerlink" title="设置段描述符"></a>设置段描述符</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs bash">void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int <span class="hljs-built_in">limit</span>, int base, int ar)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">limit</span> &gt; 0xfffff) &#123;<br>ar |= 0x8000; /* G_bit = 1 */<br><span class="hljs-built_in">limit</span> /= 0x1000;<br>&#125;<br>sd-&gt;limit_low    = <span class="hljs-built_in">limit</span> &amp; 0xffff;<br>sd-&gt;base_low     = base &amp; 0xffff;<br>sd-&gt;base_mid     = (base &gt;&gt; 16) &amp; 0xff;<br>sd-&gt;access_right = ar &amp; 0xff;<br>sd-&gt;limit_high   = ((limit &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0</span>x0f) | ((ar &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0</span>xf0);<br>sd-&gt;base_high    = (base &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0</span>xff;<br>return;<br>&#125; <br>这个set_segmdesc函数用于设置一个段描述符（Segment Descriptor），它是操作系统或系统软件中管理内存的关键数据结构，尤其在保护模式下。该函数将段限长（limit）、段基址（base）、访问权限（ar）等参数填充到SEGMENT_DESCRIPTOR结构体中。<br><br>函数功能解析<br>参数介绍：<br>struct SEGMENT_DESCRIPTOR *sd:<br>指向一个段描述符的指针，用来存储段描述符相关的信息。<br>unsigned int limit:<br>段的限长，表示该段的大小。它通常是段最后一个可访问的字节的偏移量。段限长有 <span class="hljs-number">20</span> 位，高 <span class="hljs-number">4</span> 位存储在limit_high，低 <span class="hljs-number">16</span> 位存储在limit_low。<br>int base:<br>段基址，表示段在内存中的起始地址。段基址有 <span class="hljs-number">32</span> 位，分为三个部分存储在描述符中（base_low、base_mid、base_high）。<br>int ar:<br>访问权限（Access Right），包含该段的类型、特权级别等属性。通常使用该值设置段的访问权限位。<br>函数逻辑：<br>检查 limit 是否大于 <span class="hljs-number">0</span>xFFFFF：<br><br>if (limit &gt; <span class="hljs-number">0</span>xfffff) &#123;<br>如果段限长大于 <span class="hljs-number">1</span> MB（<span class="hljs-number">0</span>xFFFFF），则表示需要使用 <span class="hljs-number">4</span>KB 粒度进行管理。此时设置G_bit为 <span class="hljs-number">1</span>（ar |= <span class="hljs-number">0</span>x8000;），并将limit除以<span class="hljs-number">0</span>x1000（即将段限长换算成以 <span class="hljs-number">4</span>KB 为单位的长度）。<br>G_bit（Granularity bit）用于指示段限长是以字节为单位（G=<span class="hljs-number">0</span>）还是以 <span class="hljs-number">4</span>KB 为单位（G=<span class="hljs-number">1</span>）。<br>设置段描述符的 limit 和 base：<br><br>sd-&gt;limit_low = limit &amp; <span class="hljs-number">0</span>xffff;<br><br>将段限长的低 <span class="hljs-number">16</span> 位存入limit_low。<br>sd-&gt;base_low = base &amp; <span class="hljs-number">0</span>xffff;<br><br>将段基址的低 <span class="hljs-number">16</span> 位存入base_low。<br>sd-&gt;base_mid = (base &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0</span>xff;<br><br>将段基址的中 <span class="hljs-number">8</span> 位存入base_mid。<br>sd-&gt;access_right = ar &amp; <span class="hljs-number">0</span>xff;<br><br>访问权限的低 <span class="hljs-number">8</span> 位（ar &amp; <span class="hljs-number">0</span>xff）存入access_right。<br>设置 limit 高位和 base 高位：<br><br>sd-&gt;limit_high = ((limit &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0</span>x0f) | ((ar &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0</span>xf0);<br><br>段限长的高 <span class="hljs-number">4</span> 位（(limit &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0</span>x0f）存入limit_high的低 <span class="hljs-number">4</span> 位。<br>ar的高 <span class="hljs-number">4</span> 位（(ar &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0</span>xf0，包括一些控制标志如G_bit等）存入limit_high的高 <span class="hljs-number">4</span> 位。<br>sd-&gt;base_high = (base &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0</span>xff;<br><br>将段基址的高 <span class="hljs-number">8</span> 位存入base_high。<br>结构体中的字段如何映射：<br>段描述符一般是 <span class="hljs-number">8</span> 个字节的结构，在此函数中被分解为以下部分：<br>段限长（limit）：<br>低 <span class="hljs-number">16</span> 位：limit_low。<br>高 <span class="hljs-number">4</span> 位：limit_high的低 <span class="hljs-number">4</span> 位。<br>段基址（base）：<br>低 <span class="hljs-number">16</span> 位：base_low。<br>中 <span class="hljs-number">8</span> 位：base_mid。<br>高 <span class="hljs-number">8</span> 位：base_high。<br>访问权限（ar）：<br>低 <span class="hljs-number">8</span> 位：access_right。<br>高 <span class="hljs-number">4</span> 位：limit_high的高 <span class="hljs-number">4</span> 位。<br>总结<br>这个函数将段限长（limit）和段基址（base）等信息打包成一个段描述符，并处理了可能的 <span class="hljs-number">4</span>KB 粒度情况。关键步骤包括处理段限长大于<span class="hljs-number">1</span>MB时的G_bit设定，以及分割段限长和段基址分别存储在描述符的不同字段中。<br></code></pre></td></tr></table></figure><h1 id="设置中断描述符"><a href="#设置中断描述符" class="headerlink" title="设置中断描述符"></a>设置中断描述符</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs bash">struct GATE_DESCRIPTOR &#123;<br>short offset_low, selector;<br>char dw_count, access_right;<br>short offset_high;<br>&#125;;<br>`GATE_DESCRIPTOR` 结构体用于描述 **中断门**、**陷阱门**或 **调用门** 等，主要用于在 x86 架构的保护模式下定义中断和异常处理。它的各个字段承载了与这些门相关的重要信息。以下是该结构体的详细解析：<br><br><span class="hljs-comment">### GATE_DESCRIPTOR 结构体</span><br>```c<br>struct GATE_DESCRIPTOR &#123;<br>    short offset_low;     // 偏移地址的低16位<br>    short selector;       // 段选择子<br>    char dw_count;        // 如果是调用门，表示堆栈要复制的参数个数，其他类型忽略<br>    char access_right;    // 门的属性和访问权限<br>    short offset_high;    // 偏移地址的高16位<br>&#125;;<br>```<br><br><span class="hljs-comment">### 字段解析</span><br><br>1. **offset_low**：<br>   - 类型：`short`<br>   - 说明：中断处理程序地址的低16位。处理器在中断或异常发生时会根据这个偏移地址开始执行处理程序。<br><br>2. **selector**：<br>   - 类型：`short`<br>   - 说明：段选择子，通常指向内核代码段的段描述符。它用于确定中断处理程序所在的代码段，结合偏移量一起组成完整的地址。<br><br>3. **dw_count**：<br>   - 类型：`char`<br>   - 说明：对于 **调用门**（Call Gate），该字段表示堆栈要复制的参数个数。在 **中断门** 和 **陷阱门** 中，这个字段通常被忽略，设为0。<br><br>4. **access_right**：<br>   - 类型：`char`<br>   - 说明：描述符的访问权限和属性。它的具体内容可能包括以下几位：<br>     - **P** (Present)：表示门描述符是否有效（是否存在）。<br>     - **DPL** (Descriptor Privilege Level)：描述符的特权级别，范围通常从0（最高）到3（最低）。<br>     - **Type**：描述符的类型（如中断门、陷阱门或调用门）。通常，中断门的类型为0xE（1110），陷阱门的类型为0xF（1111）。<br><br>5. **offset_high**：<br>   - 类型：`short`<br>   - 说明：中断处理程序地址的高16位。结合 `offset_low`，这两个字段共同组成完整的32位处理程序地址。<br><br><span class="hljs-comment">### 总结</span><br>`GATE_DESCRIPTOR` 结构体是中断描述符表（IDT）中中断门、陷阱门和调用门的关键数据结构。它通过提供完整的中断处理程序地址、段选择子和访问权限等信息，确保 CPU 能够在发生中断或异常时正确地跳转到相应的处理程序并执行相应的安全检查。<br></code></pre></td></tr></table></figure><h1 id="初始化PIC"><a href="#初始化PIC" class="headerlink" title="初始化PIC"></a>初始化PIC</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash">pic:在操作系统中，**PIC** 是 **Programmable Interrupt Controller（可编程中断控制器）** 的缩写。它是一种硬件设备，用于管理多个硬件设备发出的中断请求，并将这些请求发送给 CPU，以便 CPU 能够有序地处理这些中断信号。<br><br><span class="hljs-comment">### PIC 的主要功能：</span><br>1. **中断管理**：<br>   PIC 接收来自不同硬件设备的中断请求（IRQ，Interrupt Request），例如键盘、鼠标、硬盘等设备发出的请求，并决定以什么顺序向 CPU 发送这些请求。<br><br>2. **优先级处理**：<br>   PIC 会为不同的中断请求设置优先级。例如，定时器的中断可能比键盘输入中断更高优先级。PIC 确保优先级较高的中断会优先处理，而低优先级的中断可能需要等待或被中断。<br><br>3. **中断屏蔽**：<br>   PIC 还可以屏蔽某些中断，防止某些中断请求被传递给 CPU。如果某个设备暂时不需要 CPU 的处理，可以通过设置屏蔽位来忽略它的中断请求。<br><br>4. **中断级联**：<br>   PIC 可以与其他 PIC 级联，以扩展可以管理的中断数量。在传统的 x86 架构中，使用了两个 8259A PIC 控制器来管理 16 个中断。<br><br><span class="hljs-comment">### 经典的 PIC —— 8259A</span><br>在早期的 x86 架构中，**8259A** 是一种常见的 PIC 控制器。标准的 PC 机中使用两个 8259A 控制器级联工作：<br>- **主 PIC（PIC0）**：负责管理 IRQ0 到 IRQ7 的中断请求。<br>- **从 PIC（PIC1）**：负责管理 IRQ8 到 IRQ15 的中断请求，并通过主 PIC 的 IRQ2 通道连接到 CPU。<br><br><span class="hljs-comment">### 8259A 工作原理</span><br>1. **IRQ 线路**：<br>   每个设备都连接到一个指定的 IRQ 线路，当设备需要 CPU 处理时，它会发送一个中断请求信号到对应的 IRQ 线路上。例如，键盘使用 IRQ1，系统定时器使用 IRQ0。<br><br>2. **中断向量表**：<br>   当一个中断请求到达 PIC，PIC 会生成一个中断向量，并通过中断向量表查找对应的中断服务例程（ISR，Interrupt Service Routine），然后将控制权交给操作系统的相应 ISR 来处理该中断。<br><br>3. **初始化与配置**：<br>   8259A PIC 需要进行初始化，以便设置中断向量基址、级联关系和中断屏蔽等。这个过程一般是在操作系统启动时完成的。例如，主 PIC 的 IRQ0-7 映射到 CPU 的中断向量 `INT 20H` 到 `INT 27H`，从 PIC 的 IRQ8-15 映射到 `INT 28H` 到 `INT 2FH`。<br><br><span class="hljs-comment">### 常见的 8259A PIC 寄存器</span><br>1. **IMR（Interrupt Mask Register）**：<br>   中断屏蔽寄存器，用于屏蔽不需要的中断。例如，如果想要屏蔽键盘中断，可以设置相应的位。<br><br>2. **ICW（Initialization Command Word）**：<br>   初始化命令字，用于配置 PIC 的工作模式。例如，ICW 设置是否使用级联模式、是否使用边缘触发等。<br><br>3. **ISR（In-Service Register）**：<br>   中断服务寄存器，表示哪些中断正在被处理。<br><br><span class="hljs-comment">### APIC 和 IO-APIC</span><br>随着现代操作系统和硬件的复杂化，传统的 8259A PIC 已经逐渐被 **APIC**（Advanced Programmable Interrupt Controller，高级可编程中断控制器）和 **IO-APIC**（Input/Output APIC）取代。<br><br>- **APIC**：可以支持更多的中断，提供更灵活的中断处理方式，通常用于多核系统中的中断管理。每个 CPU 核心都有一个本地 APIC，用于处理自身的中断。<br>- **IO-APIC**：用于接收外部设备的中断请求，类似于传统的 PIC，但支持更多的中断线（超过 16 条），并能更有效地处理中断。<br><br><span class="hljs-comment">### 总结</span><br>**PIC** 是管理硬件中断请求的关键设备，尤其是在传统的 x86 架构中，**8259A PIC** 用于协调多个外部设备的中断请求，并将其顺序地传递给 CPU。随着技术发展，现代系统更多使用 **APIC** 和 **IO-APIC** 这样的高级中断控制器来支持多核处理器和更多设备。<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">void init_pic(void)<br>/* PIC初始化 */<br>&#123;<br>io_out8(PIC0_IMR,  0xff  ); /* 禁止所有中断 */<br>io_out8(PIC1_IMR,  0xff  ); /* 禁止所有中断 */<br><br>io_out8(PIC0_ICW1, 0x11  ); /* 边缘触发模式（edge trigger mode） */<br>io_out8(PIC0_ICW2, 0x20  ); /* IRQ0-7由INT20-27接收 */<br>io_out8(PIC0_ICW3, 1 &lt;&lt; <span class="hljs-string">2); /* PIC1由IRQ2相连 */</span><br><span class="hljs-string">io_out8(PIC0_ICW4, 0x01  ); /* 无缓冲区模式 */</span><br><span class="hljs-string"></span><br><span class="hljs-string">io_out8(PIC1_ICW1, 0x11  ); /* 边缘触发模式（edge trigger mode） */</span><br><span class="hljs-string">io_out8(PIC1_ICW2, 0x28  ); /* IRQ8-15由INT28-2f接收 */</span><br><span class="hljs-string">io_out8(PIC1_ICW3, 2</span>     ); /* PIC1由IRQ2连接 */<br>io_out8(PIC1_ICW4, 0x01  ); /* 无缓冲区模式 */<br><br>io_out8(PIC0_IMR,  0xfb  ); /* 11111011 PIC1以外全部禁止 */<br>io_out8(PIC1_IMR,  0xff  ); /* 11111111 禁止所有中断 */<br><br><span class="hljs-built_in">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="制作中断处理程序"><a href="#制作中断处理程序" class="headerlink" title="制作中断处理程序"></a>制作中断处理程序</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">IRQ:**IRQ** (Interrupt Request，**中断请求**) 是计算机系统中用于通知处理器有外部设备需要处理的信号。外部设备（如键盘、鼠标、硬盘等）通过发出 IRQ 信号来请求 CPU 的处理，这样 CPU 可以暂时中断当前的工作，转去处理设备的请求。<br><br><span class="hljs-comment">### 详细解释：</span><br>1. **中断机制**：<br>   在一个多任务系统中，CPU 会不断地执行当前任务。但外设可能随时需要 CPU 的帮助，例如键盘按键、网络数据到达等。如果没有中断机制，CPU 就需要不断轮询（polling）设备来判断是否需要处理它们的请求，这样会非常浪费 CPU 资源。中断机制通过外设主动向 CPU 发出信号来解决这个问题，当一个设备发出中断信号时，CPU 会暂停当前的工作，处理中断请求（IRQ），处理完后再恢复原来的任务。<br><br>2. **IRQ 的工作流程**：<br>   - 当外设发出中断请求时，会通过中断控制器（如 8259 PIC）将中断信号传递给 CPU。<br>   - CPU 识别到中断信号后，会暂停当前的任务，并执行对应的中断服务程序（ISR，Interrupt Service Routine）。<br>   - ISR 处理完中断后，CPU 恢复原先的任务，继续执行。<br><br>3. **IRQ 号**：<br>   每个外设对应一个特定的中断号（IRQ 号），这些中断号用于区分不同设备的中断请求。常见的 IRQ 号包括：<br>   - **IRQ0**：系统时钟（定时器）中断。<br>   - **IRQ1**：键盘中断。<br>   - **IRQ2**：主 PIC 用于连接从 PIC 的中断。<br>   - **IRQ3** 和 **IRQ4**：用于串行通信端口。<br>   - **IRQ7**：并行端口中断。<br><br>   不同设备通常会有不同的 IRQ 号，如果两个设备使用相同的 IRQ 号，就会导致 **IRQ 冲突**，这会影响系统的正常运行。<br><br>4. **硬件和软件 IRQ**：<br>   - **硬件中断**：由外设硬件发起的中断请求（如键盘输入、硬盘读写等）。<br>   - **软件中断**：由软件发起的中断请求，通常通过特殊的指令触发，比如 `INT` 指令。<br><br><span class="hljs-comment">### 总结：</span><br>IRQ 是计算机中断机制的核心概念，通过中断请求，外部设备可以主动向 CPU 请求服务，而不需要 CPU 不断地查询设备的状态，从而提高了系统的效率。<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs bash">这段代码定义了一个名为 `inthandler21` 的中断处理函数，专门用于处理来自 **PS/2 键盘**的中断（IRQ 1）。它实现了一个简单的处理逻辑，即在屏幕上显示一条提示消息，然后进入一个无限循环，防止系统继续运行。这种代码通常用于调试或处理特定的错误情况。<br><br><span class="hljs-comment">### 代码解析：</span><br><br>```c<br>void inthandler21(int *esp)<br>/* 来自PS/2键盘的中断 */<br>&#123;<br>    struct BOOTINFO *binfo = (struct BOOTINFO *) ADR_BOOTINFO;<br>    boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_000000, 0, 0, 32 * 8 - 1, 15);<br>    putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 0, 0, COL8_FFFFFF, <span class="hljs-string">&quot;INT 21 (IRQ-1) : PS/2 keyboard&quot;</span>);<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        io_hlt();<br>    &#125;<br>&#125;<br>```<br><br><span class="hljs-comment">### 主要步骤解析：</span><br><br>1. **函数原型**：<br>   ```c<br>   void inthandler21(int *esp)<br>   ```<br>   这是一个键盘中断处理函数。参数 `esp` 是一个指向堆栈指针的指针，通常用作中断处理程序的标准接口，在实际处理中可能不直接使用。<br><br>2. **获取引导信息**：<br>   ```c<br>   struct BOOTINFO *binfo = (struct BOOTINFO *) ADR_BOOTINFO;<br>   ```<br>   这里通过强制类型转换将 `ADR_BOOTINFO` 解析为一个指向 `BOOTINFO` 结构的指针。`BOOTINFO` 结构通常存储有关屏幕信息（如显存地址、屏幕宽度和高度等），这些信息可以用来操作显示输出。<br><br>3. **填充屏幕区域**：<br>   ```c<br>   boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_000000, 0, 0, 32 * 8 - 1, 15);<br>   ```<br>   使用 `boxfill8` 函数在屏幕上填充一块区域。这个函数通常用来绘制矩形框或清除屏幕。参数含义如下：<br>   - `binfo-&gt;vram`：显存的起始地址，表示将绘制内容写入的显存区域。<br>   - `binfo-&gt;scrnx`：屏幕的宽度，表示一行有多少像素。<br>   - `COL8_000000`：颜色代码，`000000` 表示黑色。<br>   - `0, 0`：矩形的起始坐标 (0, 0)。<br>   - `32 * 8 - 1, 15`：矩形的宽度和高度，宽度是 32 个字符，每个字符占 8 个像素。<br><br>4. **在屏幕上输出文本**：<br>   ```c<br>   putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 0, 0, COL8_FFFFFF, <span class="hljs-string">&quot;INT 21 (IRQ-1) : PS/2 keyboard&quot;</span>);<br>   ```<br>   这行代码通过 `putfonts8_asc` 函数在屏幕的 (0, 0) 位置以白色（`COL8_FFFFFF`）显示字符串 `<span class="hljs-string">&quot;INT 21 (IRQ-1) : PS/2 keyboard&quot;</span>`。这告诉用户 PS/2 键盘的中断（IRQ1）已经触发，并且该中断号为 21。<br><br>5. **无限循环**：<br>   ```c<br>   <span class="hljs-keyword">for</span> (;;) &#123;<br>       io_hlt();<br>   &#125;<br>   ```<br>   这是一个无限循环，`io_hlt()` 函数会让 CPU 进入空闲状态，直到下一次中断发生。由于这里的循环没有退出条件，CPU 会一直停在这里，导致系统在处理中断后不再继续执行其他任务。<br><br><span class="hljs-comment">### 代码用途：</span><br>这段代码可能用于在调试操作系统的早期阶段时，捕捉来自 PS/2 键盘的中断。通过将中断捕捉后在屏幕上打印一条信息，开发者可以确认中断是否正常工作。由于它在中断处理完后进入了无限循环，意味着系统中断发生后会停在这里，等待进一步的调试或重启。<br><br><span class="hljs-comment">### 改进建议：</span><br>1. **正常处理键盘输入**：在实际的键盘中断处理中，可以读取键盘缓冲区中的按键信息，并将其传递给操作系统，更新按键状态或触发相关事件。<br>2. **退出无限循环**：在生产环境中，应该避免无限循环，正常处理中断后应返回系统继续工作。<br><br><span class="hljs-comment">### 总结：</span><br>这段代码是一个简单的键盘中断处理程序，用于捕获 PS/2 键盘的中断，并显示调试信息。处理完中断后，程序进入了无限循环，这是典型的调试方式，用来确定中断是否被正确触发。<br></code></pre></td></tr></table></figure><h1 id="将函数注册到IDT"><a href="#将函数注册到IDT" class="headerlink" title="将函数注册到IDT"></a>将函数注册到IDT</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs bash">set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32);<br>set_gatedesc(idt + 0x27, (int) asm_inthandler27, 2 * 8, AR_INTGATE32);<br>set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32);<br>`set_gatedesc` 函数用于设置 **中断门描述符**（GATE_DESCRIPTOR），它主要配置中断描述符表（IDT）中每个中断门的相关属性。通过该函数，可以指定中断处理程序的偏移地址、段选择子、访问权限等信息。<br><br><span class="hljs-comment">### 函数解析</span><br><br>```c<br>void set_gatedesc(struct GATE_DESCRIPTOR *gd, int offset, int selector, int ar)<br>&#123;<br>    gd-&gt;offset_low   = offset &amp; 0xffff;                  // 偏移地址的低16位<br>    gd-&gt;selector     = selector;                          // 段选择子<br>    gd-&gt;dw_count     = (ar &gt;&gt; 8) &amp; 0xff;                 // 如果是调用门，设置参数个数；其他门可忽略<br>    gd-&gt;access_right = ar &amp; 0xff;                        // 门的访问权限<br>    gd-&gt;offset_high  = (offset &gt;&gt; 16) &amp; 0xffff;         // 偏移地址的高16位<br>    <span class="hljs-built_in">return</span>;<br>&#125;<br>```<br><br><span class="hljs-comment">### 各参数及字段的意义</span><br><br>1. **参数**：<br>   - `struct GATE_DESCRIPTOR *gd`：指向中断门描述符的指针。<br>   - `int offset`：中断处理程序的偏移地址，表示要跳转到的具体位置。<br>   - `int selector`：段选择子，通常指向处理程序代码所在的段（在GDT中）。<br>   - `int ar`：访问权限，包含描述符的类型和特权级等信息。<br><br>2. **字段设置**：<br>   - `gd-&gt;offset_low`：<br>     - 设置中断处理程序地址的低16位。通过 `offset &amp; 0xffff` 将偏移地址的低16位提取出来。<br>   - `gd-&gt;selector`：<br>     - 设置段选择子，用于指定中断处理程序的代码段。这个选择子通常指向GDT中有效的代码段。<br>   - `gd-&gt;dw_count`：<br>     - 这个字段在调用门中表示参数的个数，其他类型的门可以忽略。通过 `ar &gt;&gt; 8` 提取权限位中的相关信息。<br>   - `gd-&gt;access_right`：<br>     - 设置访问权限，包含门的类型和特权级信息。通过 `ar &amp; 0xff` 提取访问权限的低8位。<br>   - `gd-&gt;offset_high`：<br>     - 设置中断处理程序地址的高16位。通过 `(offset &gt;&gt; 16) &amp; 0xffff` 提取偏移地址的高16位。<br><br><span class="hljs-comment">### 使用场景</span><br>在系统启动时，通常会调用 `set_gatedesc` 函数来初始化IDT中的每个中断门。这个过程包括设置每个中断的处理程序地址、对应的段选择子和权限信息。这样，当中断发生时，CPU能够通过IDT找到正确的处理程序，并且根据设定的权限进行适当的安全检查。<br><br><span class="hljs-comment">### 示例</span><br>假设你需要为中断向量 `0x20` 设置一个中断门描述符，指向 `interrupt_handler` 函数，可能的调用方式如下：<br><br>```c<br>set_gatedesc(&amp;idt[0x20], (int)interrupt_handler, selector, access_right);<br>```<br><br>这里，`interrupt_handler` 是中断处理程序的地址，`selector` 是指向代码段的段选择子，`access_right` 是指该中断的权限和类型标志。<br><br><span class="hljs-comment">### 总结</span><br>`set_gatedesc` 函数是设置中断门描述符的关键函数，通过配置偏移地址、段选择子和访问权限，确保系统能够正确处理各种中断和异常情况。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>05_DAY</title>
    <link href="/2024/10/10/05-DAY/"/>
    <url>/2024/10/10/05-DAY/</url>
    
    <content type="html"><![CDATA[<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>内容地址连续</p><h1 id="显示字符"><a href="#显示字符" class="headerlink" title="显示字符"></a>显示字符</h1><p>1.描绘像素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">void putfont8(char *vram, int xsize, int x, int y, char c, char *font)<br>&#123;<br>int i;<br>char *p, d /* data */;<br><span class="hljs-keyword">for</span> (i = 0; i &lt; 16; i++) &#123;<br>p = vram + (y + i) * xsize + x;<br>d = font[i];<br><span class="hljs-keyword">if</span> ((d &amp; <span class="hljs-number">0</span>x80) != <span class="hljs-number">0</span>) &#123; p[<span class="hljs-number">0</span>] = c; &#125;<br>if ((d &amp; <span class="hljs-number">0</span>x40) != <span class="hljs-number">0</span>) &#123; p[<span class="hljs-number">1</span>] = c; &#125;<br>if ((d &amp; <span class="hljs-number">0</span>x20) != <span class="hljs-number">0</span>) &#123; p[<span class="hljs-number">2</span>] = c; &#125;<br>if ((d &amp; <span class="hljs-number">0</span>x10) != <span class="hljs-number">0</span>) &#123; p[<span class="hljs-number">3</span>] = c; &#125;<br>if ((d &amp; <span class="hljs-number">0</span>x08) != <span class="hljs-number">0</span>) &#123; p[<span class="hljs-number">4</span>] = c; &#125;<br>if ((d &amp; <span class="hljs-number">0</span>x04) != <span class="hljs-number">0</span>) &#123; p[<span class="hljs-number">5</span>] = c; &#125;<br>if ((d &amp; <span class="hljs-number">0</span>x02) != <span class="hljs-number">0</span>) &#123; p[<span class="hljs-number">6</span>] = c; &#125;<br>if ((d &amp; <span class="hljs-number">0</span>x01) != <span class="hljs-number">0</span>) &#123; p[<span class="hljs-number">7</span>] = c; &#125;<br>&#125;<br>return;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.sprintf</p><p>sprintf(地址,格式,值,值,…);</p><h1 id="描绘鼠标"><a href="#描绘鼠标" class="headerlink" title="描绘鼠标"></a>描绘鼠标</h1><p>和显示文字一样的思路</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash">void init_mouse_cursor8(char *mouse, char bc)<br>/* マウスカーソルを準備（16x16） */<br>&#123;<br>static char cursor[16][16] = &#123;<br><span class="hljs-string">&quot;**************..&quot;</span>,<br><span class="hljs-string">&quot;*OOOOOOOOOOO*...&quot;</span>,<br><span class="hljs-string">&quot;*OOOOOOOOOO*....&quot;</span>,<br><span class="hljs-string">&quot;*OOOOOOOOO*.....&quot;</span>,<br><span class="hljs-string">&quot;*OOOOOOOO*......&quot;</span>,<br><span class="hljs-string">&quot;*OOOOOOO*.......&quot;</span>,<br><span class="hljs-string">&quot;*OOOOOOO*.......&quot;</span>,<br><span class="hljs-string">&quot;*OOOOOOOO*......&quot;</span>,<br><span class="hljs-string">&quot;*OOOO**OOO*.....&quot;</span>,<br><span class="hljs-string">&quot;*OOO*..*OOO*....&quot;</span>,<br><span class="hljs-string">&quot;*OO*....*OOO*...&quot;</span>,<br><span class="hljs-string">&quot;*O*......*OOO*..&quot;</span>,<br><span class="hljs-string">&quot;**........*OOO*.&quot;</span>,<br><span class="hljs-string">&quot;*..........*OOO*&quot;</span>,<br><span class="hljs-string">&quot;............*OO*&quot;</span>,<br><span class="hljs-string">&quot;.............***&quot;</span><br>&#125;;<br>int x, y;<br><br><span class="hljs-keyword">for</span> (y = 0; y &lt; 16; y++) &#123;<br><span class="hljs-keyword">for</span> (x = 0; x &lt; 16; x++) &#123;<br><span class="hljs-keyword">if</span> (cursor[y][x] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>mouse[y * 16 + x] = COL8_000000;<br>&#125;<br><span class="hljs-keyword">if</span> (cursor[y][x] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>mouse[y * 16 + x] = COL8_FFFFFF;<br>&#125;<br><span class="hljs-keyword">if</span> (cursor[y][x] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>mouse[y * 16 + x] = bc;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">return</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">void putblock8_8(char *vram, int vxsize, int pxsize,<br>int pysize, int px0, int py0, char *buf, int bxsize)<br>&#123;<br>int x, y;<br><span class="hljs-keyword">for</span> (y = 0; y &lt; pysize; y++) &#123;<br><span class="hljs-keyword">for</span> (x = 0; x &lt; pxsize; x++) &#123;<br>vram[(py0 + y) * vxsize + (px0 + x)] = buf[y * bxsize + x];<br>&#125;<br>&#125;<br><span class="hljs-built_in">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="GDT和IDT"><a href="#GDT和IDT" class="headerlink" title="GDT和IDT"></a>GDT和IDT</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>在操作系统中，GDT（Global Descriptor Table，全局描述符表）是一种用于内存段管理的数据结构，主要用于定义系统中各个段的属性和权限。在x86架构的处理器中，GDT是内存分段机制的核心部分，负责描述内存段的信息，比如代码段、数据段、堆栈段等。<br><br>GDT的作用<br>GDT的主要作用是通过段描述符来定义内存段的基址、长度以及访问权限。每个GDT条目都称为一个段描述符，它包含以下信息：<br><br>基址（Base）：段在内存中的起始地址。<br>段界限（Limit）：段的大小（即段的长度），通常是以字节为单位的一个值。<br>段的类型和属性：包括该段是否可读、可写、可执行，以及该段是系统段还是用户段等信息。<br>特权级别（Privilege Level）：用于定义对段的访问权限，分为0到3级，0级为最高权限，3级为最低权限。<br></code></pre></td></tr></table></figure><p>初始化GDT</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs bash">这个结构体 SEGMENT_DESCRIPTOR 是一个典型的用于描述段描述符的结构，在类似x86的操作系统或底层内核开发中经常见到。它的目的是定义段的起始地址（基址）和大小（段界限），以及访问权限等属性，通常用于全局描述符表（GDT）或局部描述符表（LDT）中。<br><br>解析这个结构体：<br>c<br>复制代码<br>struct SEGMENT_DESCRIPTOR &#123;<br>    short limit_low;    // 段界限的低16位<br>    short base_low;     // 段基址的低16位<br>    char base_mid;      // 段基址的中8位<br>    char access_right;  // 访问权限<br>    char limit_high;    // 段界限的高4位 + 其他标志位<br>    char base_high;     // 段基址的高8位<br>&#125;;<br>各字段的意义：<br>limit_low (段界限低位)：<br><br>用于描述段的大小，表示段的长度。这个字段存储段界限的低16位。<br>base_low (基址低位)：<br><br>描述段在内存中的起始地址（基址），这个字段存储基址的低16位。<br>base_mid (基址中位)：<br><br>存储段基址的中间8位。<br>access_right (访问权限)：<br><br>用于定义段的访问权限和属性，比如是否可读、可写、可执行，段的特权级别（ring 0到ring 3），段是否存在等。典型的访问权限标志包括：<br>P (Present)：段是否存在。<br>DPL (Descriptor Privilege Level)：段的权限等级。<br>S：描述符类型，指明是系统段还是代码/数据段。<br>Type：定义段的具体类型，如可执行、可读、可写等。<br>limit_high (段界限高位)：<br><br>段界限的高4位，剩余的4位通常存储其他标志位（如G和D/B标志）。<br>G (Granularity)：段界限的粒度，决定界限以字节为单位还是4KB为单位。<br>D/B (Size)：控制段的操作数大小，通常用于指定是否是16位还是32位段。<br>base_high (基址高位)：<br><br>存储段基址的高8位。<br>整个结构体的作用：<br>这个结构体提供了一种存储段描述符信息的方式。通过这个结构，操作系统可以定义每个内存段的起始地址、大小、权限以及如何访问这些段。<br>通常，在保护模式下，处理器会通过GDT或LDT来管理段描述符。每次访问内存时，都会用段选择子查找GDT/LDT中的段描述符，并根据这个结构体中的信息确定具体的内存地址和访问权限<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">void init_gdtidt(void)<br>&#123;<br>struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) 0x00270000;<br>struct GATE_DESCRIPTOR    *idt = (struct GATE_DESCRIPTOR    *) 0x0026f800;<br>int i;<br><br>/* GDT初始化 */<br><span class="hljs-keyword">for</span> (i = 0; i &lt; 8192; i++) &#123;<br>set_segmdesc(gdt + i, 0, 0, 0);<br>&#125;<br>set_segmdesc(gdt + 1, 0xffffffff, 0x00000000, 0x4092);<br>set_segmdesc(gdt + 2, 0x0007ffff, 0x00280000, 0x409a);<br>load_gdtr(0xffff, 0x00270000);<br><br>/* IDT初始化 */<br><span class="hljs-keyword">for</span> (i = 0; i &lt; 256; i++) &#123;<br>set_gatedesc(idt + i, 0, 0, 0);<br>&#125;<br>load_idtr(0x7ff, 0x0026f800);<br><br><span class="hljs-built_in">return</span>;<br>&#125;<br><br>void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int <span class="hljs-built_in">limit</span>, int base, int ar)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">limit</span> &gt; 0xfffff) &#123;<br>ar |= 0x8000; /* G_bit = 1 */<br><span class="hljs-built_in">limit</span> /= 0x1000;<br>&#125;<br>sd-&gt;limit_low    = <span class="hljs-built_in">limit</span> &amp; 0xffff;<br>sd-&gt;base_low     = base &amp; 0xffff;<br>sd-&gt;base_mid     = (base &gt;&gt; 16) &amp; 0xff;<br>sd-&gt;access_right = ar &amp; 0xff;<br>sd-&gt;limit_high   = ((limit &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0</span>x0f) | ((ar &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0</span>xf0);<br>sd-&gt;base_high    = (base &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0</span>xff;<br>return;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>GATE_DESCRIPTOR 结构体通常用于描述 中断门（Interrupt Gate）、陷阱门（Trap Gate）、或者 调用门（Call Gate）等，在x86架构的保护模式下用于中断处理、异常处理和系统调用等机制。这些门描述符位于 IDT（中断描述符表，Interrupt Descriptor Table）中，用于定义当某个中断或异常发生时，处理器如何跳转到相应的处理程序。<br><br>解析这个结构体：<br>c<br>复制代码<br>struct GATE_DESCRIPTOR &#123;<br>    short offset_low;     // 偏移地址的低16位<br>    short selector;       // 段选择子<br>    char dw_count;        // 如果是调用门，表示堆栈要复制的参数个数，其他类型忽略<br>    char access_right;    // 门的属性和访问权限<br>    short offset_high;    // 偏移地址的高16位<br>&#125;;<br>各字段的意义：<br>offset_low（偏移地址低位）：<br><br>存储目标处理程序地址（也就是中断处理程序、陷阱处理程序等）的低16位。即，处理器在中断或异常发生时，会跳转到这个地址开始执行中断服务程序。<br>selector（段选择子）：<br><br>段选择子，通常指向内核的代码段（一般是GDT中的代码段描述符）。当中断或异常发生时，处理器根据该选择子找到正确的段，结合偏移量来确定要跳转的地址。<br>dw_count：<br><br>对于调用门（Call Gate）描述符，这个字段表示从调用者堆栈复制到新的堆栈的参数个数。在中断门和陷阱门中，这个字段通常为0，不起作用。<br>access_right（访问权限）：<br><br>这个字段定义了描述符的类型、特权级别以及门的相关属性。它的具体内容可能包括以下几位：<br>P (Present)：门描述符是否有效（是否存在）。<br>DPL (Descriptor Privilege Level)：描述符的特权级别，0为最高（内核态），3为最低（用户态）。这决定了哪些特权级别的代码可以使用此门。<br>Type：描述符的类型。常见类型包括中断门、陷阱门、调用门等。对于中断门和陷阱门，Type 会定义这是硬件中断、软件中断还是异常处理。<br>D：决定门描述符是32位（D=1）还是16位（D=0）。<br>offset_high（偏移地址高位）：<br><br>存储目标处理程序地址的高16位。结合offset_low，这两个字段共同组成完整的处理程序地址（32位）。<br>GATE_DESCRIPTOR 的作用<br>中断门：处理器在中断发生时，通过中断向量从IDT中找到对应的GATE_DESCRIPTOR，然后使用描述符中的信息跳转到相应的中断处理程序。<br>陷阱门：类似于中断门，但通常用于同步事件，比如软件异常。<br>调用门：用于跨段调用不同特权级别的代码。<br>示例说明：<br>当硬件中断或软件异常发生时，处理器会根据中断向量从 IDT 中查找对应的 GATE_DESCRIPTOR。通过该描述符，处理器可以找到处理程序的地址（由offset_low和offset_high指定），并使用selector指定的代码段，跳转到正确的内存位置执行中断处理程序。<br><br>总结：<br>GATE_DESCRIPTOR 结构体为处理器提供了一个用于管理中断、异常和系统调用的机制，确保在系统中断或异常时能够正确跳转到对应的服务程序，并安全、稳定地执行。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>04_Day</title>
    <link href="/2024/10/09/04-Day/"/>
    <url>/2024/10/09/04-Day/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言和画面显示的问题"><a href="#C语言和画面显示的问题" class="headerlink" title="C语言和画面显示的问题"></a>C语言和画面显示的问题</h1><p>1.用指针写入内存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">int i=0xa0000;<br>*((char *)i)=i&amp;<span class="hljs-number">0</span>x0f;<br></code></pre></td></tr></table></figure><p>2.调色版的设置。</p><p>调色版:<a href="%5B%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E9%87%8C%E9%9D%A2%E8%B0%83%E8%89%B2%E6%9D%BF(Palette">定义</a>是什么意思?-CSDN博客](<a href="https://blog.csdn.net/qq_31806049/article/details/64122054#:~:text=%E8%B0%83%E8%89%B2%E6%9D%BF">https://blog.csdn.net/qq_31806049/article/details/64122054#:~:text=调色板</a> 图像 通过将))</p><p>使用RGB模式。调色版访问步骤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.屏蔽中断<br>2.将设定号码写入0x03c8,按RGB的顺序写入0x03c9.如果还想设定下一个,省略号码,直接写入0x03c9即可<br></code></pre></td></tr></table></figure><p>3.中断屏蔽</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.io_cli 关中断<br>2.io_store_eflags 恢复中断标志<br></code></pre></td></tr></table></figure><p>4.VRAM</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.VRAM的区域为0xa0000-0xaffff<br>2.向VRAM写入颜色号可改变颜色<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>从0到1编写一个文本编辑器</title>
    <link href="/2024/08/27/%E4%BB%8E0%E5%88%B01%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <url>/2024/08/27/%E4%BB%8E0%E5%88%B01%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><p>本文的代码环境为linux，这是因为我们的文本编辑器使用<code>termios.h</code>头文件，这方便我们在底层与终端进行交互。但该头文件在Windows环境下不可用。所以我们需要使用Bash on Windows。</p><h2 id="关于Bash-on-Windows"><a href="#关于Bash-on-Windows" class="headerlink" title="关于Bash on Windows"></a>关于Bash on Windows</h2><p><strong>Bash on Windows</strong> 是 Microsoft 在 Windows 10 和 Windows 11 中引入的一个功能，现在更广泛地被称为 **Windows Subsystem for Linux (WSL)**。WSL 允许你在 Windows 操作系统上运行 Linux 环境，而无需修改代码或运行传统的虚拟机。</p><p>通过 WSL，你可以在 Windows 上直接运行 Linux 命令行工具、实用程序和应用程序，就像它们在 Linux 发行版上运行一样。这意味着你可以使用 <code>bash</code>、<code>zsh</code>、<code>vim</code>、<code>git</code>、<code>python</code>、<code>node.js</code> 等工具，以及需要 Linux 特定功能的软件，如那些依赖于 <code>&lt;termios.h&gt;</code> 的程序。更详细的了解和安装请参考<a href="https://msdn.microsoft.com/en-us/commandline/wsl/about">官方文档</a>。</p><h2 id="安装viscode编辑器并配置代码环境"><a href="#安装viscode编辑器并配置代码环境" class="headerlink" title="安装viscode编辑器并配置代码环境"></a>安装viscode编辑器并配置代码环境</h2><h3 id="安装viscode"><a href="#安装viscode" class="headerlink" title="安装viscode"></a>安装viscode</h3><p>进入<a href="https://code.visualstudio.com/">viscode官网</a>，C盘空间够的话，所有步骤点击下一步即可。</p><h2 id="配置环境-1"><a href="#配置环境-1" class="headerlink" title="配置环境"></a>配置环境</h2><p>本文代码全部由C语言编写，所以我们要在viscode使用C语言和WLS环境，相关步骤<a href="https://code.visualstudio.com/docs/cpp/config-wsl">官网文档</a>写的很详细。</p><h1 id="The-main-function"><a href="#The-main-function" class="headerlink" title="The main() function"></a>The main() function</h1><p>首先让我们创建一个名为kilo.c的函数，打开你下载的Ubuntu，输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> kilo<br></code></pre></td></tr></table></figure><p>输入<code>code</code>，vscode会自动打开。然后，我们可以在viscode中编辑我们的代码了。</p><p>我们在kilo.c中创建一个main()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    reuturn <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C语言的main()函数比较特别，他是程序的默认起点。当程序main()函数返回时，程序会退出并将返回值传递给操作系统。返回值为0代表程序运行成功。</p><p>C是编译型语言，这意味着我们需要通过C编译器运行我们的程序并将他变成可执行文件，然后我们可以在命令行中运行我们的可执行文件了。</p><p>为了编译<code>kilo.c</code>，我们需要在命令行中输入<code>cc kilo.c -o kilo</code>，不出错的话，你将会得到一个名叫<code>kilo</code>的可执行文件，<code>cc</code>代表C编译器，<code>-o</code>表示将输出文件命名为<code>kilo</code>。该命令让编译器编译kilo.c，并生成一个名字为<code>kilo</code>的可执行文件。</p><p>要运行这个可执行文件，使用<code>./kilo</code>命令。但该程序目前没有如何输出，但你可以使用<code>echo $?</code>命令来检查程序的退出状态，不出意外的话，你会看到0被打印出来。</p><h1 id="使用make编译"><a href="#使用make编译" class="headerlink" title="使用make编译"></a>使用make编译</h1><p>每次编译都要执行<code>cc kilo.c -o kilo</code>命令可能会让你厌烦，make程序允许你使用<code>make</code>命令去编译C程序。你只需要提供一个<code>Makefile</code>来告诉他如何编译程序。</p><p>创建一个叫Makefile的文件，在其中输入以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kilo: kilo.c<br>$(CC) kilo.c -o kilo -Wall -Wextra -pedantic -std=c99<br></code></pre></td></tr></table></figure><p>第一行表示<code>kilo</code>是我们想要构建的目标，而<code>kilo.c</code>是构建它所需要的文件。第二行指定了实际运行以从<code>kilo.c</code>构建<code>kilo</code>的命令。请确保第二行使用实际的制表符（Tab）进行缩进，而不是空格。你可以按照自己的喜好来缩进C文件，但是Makefile必须使用制表符。</p><p>这是因为在Makefile的语法中，制表符用于区分命令行的开始，而空格则被视为命令的一部分。如果Makefile中的规则（即依赖关系后的行）不以制表符开头，<code>make</code>程序将不会将这些行识别为命令，并可能会报错或无法正确执行。</p><p>因此，在编写Makefile时，请确保使用制表符而不是空格来缩进那些包含命令的行。这是Makefile语法的一个重要方面，也是初学者常犯的错误之一。想要更详细的了解Makefile，我推荐这篇<a href="https://seisman.github.io/how-to-write-makefile/overview.html#id2">博客</a>。</p><h1 id="使用记事本编辑代码"><a href="#使用记事本编辑代码" class="headerlink" title="使用记事本编辑代码"></a>使用记事本编辑代码</h1><p>看到这，聪明的你肯定发现了我们的viscode除了编辑代码和保存以外没有其他作用。我们使用<code>make</code>命令来编译我们的代码，使用<code>./kilo</code>来执行我们的可执行文件，该过程不需要viscode来编译运行。他在这只充当文本编辑的作用。所以我们可以用记事本来编辑我们的源码，使用上述命令编译执行即可。</p><h1 id="进入-raw-mode"><a href="#进入-raw-mode" class="headerlink" title="进入 raw mode"></a>进入 raw mode</h1><p>首先，让我们尝试读取用户的按键。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br>int <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br>  char c;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">read</span>(STDIN_FILENO, &amp;c, 1) == 1);<br>  <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>read()</code> 函数和 <code>STDIN_FILENO</code> 宏都来自 <code>&lt;unistd.h&gt;</code> 头文件。我们要求 <code>read()</code> 函数从标准输入（通常是键盘）读取1个字节到变量 <code>c</code> 中，并持续这样做，直到没有更多的字节可以读取。<code>read()</code> 函数返回它读取的字节数，当到达文件末尾时返回0。</p><p>当你运行 <code>./kilo</code>（假设这是一个文本编辑器或类似程序），你的终端会连接到标准输入，因此你的键盘输入会被读取到变量 <code>c</code> 中。然而，默认情况下，你的终端处于规范模式（也称为熟模式）。在这种模式下，键盘输入只有在用户按下回车键时才会被发送到你的程序。这对于许多程序来说是有用的：它允许用户输入一行文本，使用退格键来修正错误，直到他们得到完全按照自己意愿的输入，然后按下回车键将其发送到程序。但是，对于具有更复杂用户界面的程序（如文本编辑器），这种模式并不适用。我们希望每个按键被按下时就能立即处理，以便我们可以立即响应。</p><p>我们想要的是原始模式（raw mode）。不幸的是，没有简单的开关可以直接将终端设置为原始模式。原始模式是通过关闭终端中的许多标志来实现的，我们将在本章中逐步完成这一操作。</p><p>要退出上述程序，你可以按下 Ctrl-D 来告诉 <code>read()</code> 函数它已经到达文件末尾。或者，你也可以随时按下 Ctrl-C 来立即终止进程。</p><h1 id="按下q退出"><a href="#按下q退出" class="headerlink" title="按下q退出"></a>按下q退出</h1><p>为了演示终端的规范模式是如何工作的，我们设置用户按下q时退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br>int <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br>  char c;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">read</span>(STDIN_FILENO, &amp;c, 1) == 1 &amp;&amp; c != <span class="hljs-string">&#x27;q&#x27;</span>);<br>  <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了退出这个程序，你需要输入一行文本，其中包含字母 ‘q’，然后按下回车键。程序会逐字符地快速读取这行文本，直到它读取到 ‘q’ 为止。此时，<code>while</code> 循环将停止，程序将退出。在 ‘q’ 之后的任何字符都将留在输入队列中未被读取，你可能会看到这些字符在你的程序退出后被送入到你的 shell 中。</p><p>这是因为在规范模式下（也称为熟模式），终端会将用户输入的文本视为一个整体，直到遇到换行符（即回车键被按下）才会将其发送给程序。程序会逐字符地处理这个输入流，但一旦遇到 ‘q’，它就会停止处理并退出，而不会继续读取 ‘q’ 之后的字符。然而，由于这些字符已经被输入到终端的输入缓冲区中，当程序退出后，它们仍然存在于那里，因此可能会被下一个接收输入的程序（如你的 shell）读取并处理。</p><p>为了避免这种情况，你可以在程序退出前清空输入缓冲区，但这通常不是必需的，因为大多数 shell 和程序都能够很好地处理这种情况。然而，在处理复杂输入或需要精确控制输入行为的程序中，清空输入缓冲区可能是一个好主意。</p><h1 id="关闭回显"><a href="#关闭回显" class="headerlink" title="关闭回显"></a>关闭回显</h1><p>终端回显（Terminal Echo）是指在用户通过终端（如命令行界面）输入字符时，这些字符会立即在屏幕上显示出来的行为。这是一种常见的用户交互方式，让用户能够看到他们正在输入的内容。例如，当你在终端中键入命令或文本时，你输入的每个字符都会立即出现在屏幕上，这就是回显的作用。但目前请让我们先关闭它。我们可以通过以下方式设置终端的属性：（1）使用 <code>tcgetattr()</code> 函数将当前属性读取到一个结构体中，（2）手动修改这个结构体，（3）将修改后的结构体传递给 <code>tcsetattr()</code> 函数，以将新的终端属性写回。现在，让我们尝试以这种方式关闭 <code>ECHO</code> 功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;termios.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br>void <span class="hljs-function"><span class="hljs-title">enableRawMode</span></span>() &#123;<br>  struct termios raw;<br>  tcgetattr(STDIN_FILENO, &amp;raw);<br>  raw.c_lflag &amp;= ~(ECHO);<br>  tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;raw);<br>&#125;<br>int <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br>  enableRawMode();<br>  char c;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">read</span>(STDIN_FILENO, &amp;c, 1) == 1 &amp;&amp; c != <span class="hljs-string">&#x27;q&#x27;</span>);<br>  <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>struct termios</code>、<code>tcgetattr()</code>、<code>tcsetattr()</code>、<code>ECHO</code> 和 <code>TCSAFLUSH</code> 都来自于 <code>&lt;termios.h&gt;</code> 头文件，它们与终端（terminal）的设置和操作紧密相关。</p><ul><li><code>ECHO</code> 功能使得你输入的每个键都被打印到终端上，这样你就可以看到你正在输入什么。这在规范模式下很有用，但在我们试图在原始模式下仔细渲染用户界面时，它就会碍事。因此，我们需要关闭它。这个程序做了与之前步骤中相同的事情，只是它不会打印你正在输入的内容。如果你曾经在终端中输入密码（例如使用 <code>sudo</code> 命令时），你可能对这种模式很熟悉。</li><li>程序退出后，根据你的 shell 类型，你可能会发现你的终端仍然不会回显你输入的内容。不用担心，它仍然会监听你的输入。只需按下 Ctrl-C 开始向你的 shell 输入新的一行，然后输入 <code>reset</code> 并按下回车键。这通常可以将你的终端重置回正常状态。如果这不起作用，你可以总是重启你的终端模拟器。我们将在下一步中解决这个问题。</li><li>终端属性可以通过 <code>tcgetattr()</code> 读取到一个 <code>termios</code> 结构中。在修改这些属性后，你可以使用 <code>tcsetattr()</code> 将它们应用到终端上。<code>TCSAFLUSH</code> 参数指定了何时应用更改：在这种情况下，它会等待所有挂起的输出被写入终端，并丢弃任何尚未读取的输入。</li><li><code>c_lflag</code> 字段用于“本地标志”（local flags）。macOS 的 <code>&lt;termios.h&gt;</code> 中的注释将其描述为“其他状态的倾倒场”（dumping ground for other state），因此可以将其视为“杂项标志”。其他标志字段包括 <code>c_iflag</code>（输入标志）、<code>c_oflag</code>（输出标志）和 <code>c_cflag</code>（控制标志），我们都需要修改它们以启用原始模式。</li><li><code>ECHO</code> 是一个位标志（bitflag），其二进制表示为 <code>00000000000000000000000000001000</code>。我们使用位非（bitwise-NOT）操作符（<code>~</code>）对这个值进行操作，得到 <code>11111111111111111111111111110111</code>。然后我们将这个结果与标志字段进行位与（bitwise-AND）操作，这会将标志字段中的第四位强制设置为 0，同时保持其他所有位的当前值。在 C 语言中，像这样翻转位是很常见的操作。</li></ul><h1 id="在退出时关闭原始模式"><a href="#在退出时关闭原始模式" class="headerlink" title="在退出时关闭原始模式"></a>在退出时关闭原始模式</h1><p>在程序退出时是终端回到初始状态是一个好习惯。因此我们将会保存终端的副本，方便在程序退出时恢复它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;termios.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><br>struct termios ori_termios;<br><br>void <span class="hljs-function"><span class="hljs-title">disableRawMode</span></span>() &#123;<br>  tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;ori_termios);<br>&#125;<br><br>void <span class="hljs-function"><span class="hljs-title">enableRawMode</span></span>() &#123;<br>  tcgetattr(STDIN_FILENO, &amp;ori_termios);<br>  atexit(disableRawMode);<br>  struct termios raw=ori_termios;<br>  raw.c_lflag &amp;= ~(ECHO);<br>  tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;raw);<br>&#125;<br><br>int <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br>  enableRawMode();<br>  char c;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">read</span>(STDIN_FILENO, &amp;c, 1) == 1 &amp;&amp; c != <span class="hljs-string">&#x27;q&#x27;</span>);<br>  <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>atexit()</code> 函数来自 <code>&lt;stdlib.h&gt;</code> 头文件。我们使用它来注册我们的 <code>disableRawMode()</code> 函数，以便在程序退出时自动调用该函数，无论是通过从 <code>main()</code> 函数返回还是调用 <code>exit()</code> 函数退出。这样，我们可以确保在程序退出时，终端属性会恢复到我们程序开始时的状态。</p><p>我们将原始的终端属性存储在一个全局变量 <code>orig_termios</code> 中。在我们开始对终端属性进行修改之前，我们将 <code>orig_termios</code> 结构体赋值给 <code>raw</code> 结构体，以便制作一个原始属性的副本。</p><p>你可能会注意到，在程序退出后，遗留在缓冲区中的输入不会被送入你的 shell。这是因为当程序退出时，向 <code>tcsetattr()</code> 传递了 <code>TCSAFLUSH</code> 选项。如前所述，<code>TCSAFLUSH</code> 会在应用对终端的更改之前丢弃任何未读取的输入。</p><h1 id="关闭规范模式"><a href="#关闭规范模式" class="headerlink" title="关闭规范模式"></a>关闭规范模式</h1><p>这里有一个<code>ICANON</code>标志，它允许我们关闭规范模式。这样我们的终端不在是一行一行的读入，而是一个字一个字的读入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ba">#include &lt;stdlib.h&gt;<br>#include &lt;termios.h&gt;<br>#include &lt;unistd.h&gt;<br>struct termios orig_termios;<br>void disableRawMode() &#123; … &#125;<br>void enableRawMode() &#123;<br>  tcgetattr(STDIN_FILENO, &amp;orig_termios);<br>  atexit(disableRawMode);<br>  struct termios raw = orig_termios;<br>  raw.c_lflag &amp;= ~(ECHO | ICANON);<br>  tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;raw);<br>&#125;<br>int main() &#123; … &#125;<br></code></pre></td></tr></table></figure><p><code>ICANON</code>标志来自<code>termios.h</code>头文件，它是一个”local”flag在c_lflag字段。现在只要我们按下q程序就会退出。</p><h1 id="显示按键"><a href="#显示按键" class="headerlink" title="显示按键"></a>显示按键</h1><p>为了看到原始模式下我们的输入，我们让程序打印我们的输入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;ctype.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;termios.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br>struct termios orig_termios;<br>void <span class="hljs-function"><span class="hljs-title">disableRawMode</span></span>() &#123; … &#125;<br>void <span class="hljs-function"><span class="hljs-title">enableRawMode</span></span>() &#123; … &#125;<br>int <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br>  enableRawMode();<br>  char c;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">read</span>(STDIN_FILENO, &amp;c, 1) == 1 &amp;&amp; c != <span class="hljs-string">&#x27;q&#x27;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (iscntrl(c)) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, c);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d (&#x27;%c&#x27;)\n&quot;</span>, c, c);<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>iscntrl()</code> 函数来自 <code>&lt;ctype.h&gt;</code> 头文件，而 <code>printf()</code> 函数来自 <code>&lt;stdio.h&gt;</code> 头文件。</p><p><code>iscntrl()</code> 函数用于测试一个字符是否是控制字符。控制字符是非打印字符，我们不想将它们打印到屏幕上。ASCII 码 0-31 都是控制字符，以及 127 也是控制字符。ASCII 码 32-126 都是可打印的。（可以查看 ASCII 表来查看所有字符。）</p><p><code>printf()</code> 函数可以打印字节的多种表示形式。<code>%d</code> 告诉它将字节格式化为十进制数（即其 ASCII 码），而 <code>%c</code> 告诉它直接将字节作为字符写出。</p><p>这是一个非常有用的程序。它向我们展示了各种按键如何转换为我们读取的字节。大多数普通按键直接转换为其代表的字符。但是，尝试看看当你按下箭头键、Escape 键、Page Up、Page Down、Home、End、Backspace、Delete 或 Enter 键时会发生什么。也尝试使用 Ctrl 键的组合，如 Ctrl-A、Ctrl-B 等。</p><p>你会注意到几件有趣的事情：</p><ul><li>箭头键、Page Up、Page Down、Home 和 End 键都向终端输入 3 或 4 个字节：27、’[‘，以及一个或两个其他字符。这被称为转义序列。所有转义序列都以 27 字节开头。按下 Escape 键会发送一个单独的 27 字节作为输入。</li><li>Backspace 是字节 127。Delete 是一个 4 字节的转义序列。</li><li>Enter 是字节 10，它是一个换行符，也称为 ‘\n’。</li><li>Ctrl-A 是 1，Ctrl-B 是 2，依此类推。但是 Ctrl-C 会终止程序，对吧。不过，那些有效的 Ctrl 键组合似乎将字母 A-Z 映射到 1-26 的代码上。</li><li>顺便说一下，如果你不小心按下了 Ctrl-S，你可能会发现你的程序似乎被冻结了。你所做的是请求程序停止向你发送输出。按下 Ctrl-Q 可以告诉它恢复发送输出。</li></ul><p>另外，如果你按下 Ctrl-Z（或在某些系统上可能是 Ctrl-Y），你的程序将被挂起到后台。运行 <code>fg</code> 命令可以将其带回到前台。（在 macOS 上，这样做之后程序可能会立即退出，因为 <code>read()</code> 函数返回 -1 表示发生了错误。而在 Linux 上，似乎能够正确地恢复 <code>read()</code> 调用。）</p><h1 id="关闭ctrl-c和ctrl-s信号"><a href="#关闭ctrl-c和ctrl-s信号" class="headerlink" title="关闭ctrl-c和ctrl-s信号"></a>关闭ctrl-c和ctrl-s信号</h1><p>默认情况下，Ctrl-C 向当前进程发送 SIGINT 信号，导致进程终止，而 Ctrl-Z 向当前进程发送 SIGTSTP 信号，导致进程挂起。现在，让我们关闭这两个信号的发送。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;ctype.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;termios.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br>struct termios orig_termios;<br>void <span class="hljs-function"><span class="hljs-title">disableRawMode</span></span>() &#123; … &#125;<br>void <span class="hljs-function"><span class="hljs-title">enableRawMode</span></span>() &#123;<br>  tcgetattr(STDIN_FILENO, &amp;orig_termios);<br>  atexit(disableRawMode);<br>  struct termios raw = orig_termios;<br>  raw.c_lflag &amp;= ~(ECHO | ICANON | ISIG);<br>  tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;raw);<br>&#125;<br>int <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123; … &#125;<br></code></pre></td></tr></table></figure><p><code>ISIG</code>来自<code>termios.h</code>，现在，按下ctrl-c，你将会看到3，ctrl-z将会是26。</p><h1 id="禁止ctrl-s和ctr-q"><a href="#禁止ctrl-s和ctr-q" class="headerlink" title="禁止ctrl-s和ctr-q"></a>禁止ctrl-s和ctr-q</h1><p>默认情况下，Ctrl-S 和 Ctrl-Q 用于软件流控制。Ctrl-S 会停止数据向终端的传输，直到你按下 Ctrl-Q。</p><p>现在，让我们关闭这个功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;ctype.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;termios.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br>struct termios orig_termios;<br>void <span class="hljs-function"><span class="hljs-title">disableRawMode</span></span>() &#123; … &#125;<br>void <span class="hljs-function"><span class="hljs-title">enableRawMode</span></span>() &#123;<br>  tcgetattr(STDIN_FILENO, &amp;orig_termios);<br>  atexit(disableRawMode);<br>  struct termios raw = orig_termios;<br>  raw.c_iflag &amp;= ~(IXON);<br>  raw.c_lflag &amp;= ~(ECHO | ICANON | ISIG);<br>  tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;raw);<br>&#125;<br>int <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123; … &#125;<br></code></pre></td></tr></table></figure><p>IXON 来自于 <code>&lt;termios.h&gt;</code>。这里的 I 代表“输入标志”，而 XON 则来源于 Ctrl-S 和 Ctrl-Q 产生的两个控制字符的名称：XOFF 用于暂停传输，XON 用于恢复传输。现在，Ctrl-S 可以被解读为 19 ，而 Ctrl-Q 可以被解读为 17 。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用hexo和github搭建自己的博客</title>
    <link href="/2024/08/27/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/08/27/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>然后，简单介绍一下利用 GitHub + Hexo 搭建的原理。</p><p>GitHub 是有名的代码托管网站，而它提供了一项服务 GitHub Pages，这个 GitHub Pages 可以将我们托管在 GitHub 上的一个仓库中的 html、css 和 js 代码渲染成静态页面。当然，这个仓库是特殊的，所以每一个 GitHub 账户只能够育一个这样的仓库。将相应的博客内容上传到 GitHub 上之后，我们就可以通过 <code>https://www.username.github.io</code> 来访问自己的博客，这里的 <code>username</code> 要换成自己的用户名。比如，我的用户名是 <code>lhhi</code>，那么就可以通过 <code>https://www.lhhi.github.io</code> 来访问我的博客。</p><p>Hexo 是使用 nodejs 开发的一个快速、简洁、高效的静态博客生成器。Hexo 使用 Markdown 语法解析文章，然后渲染成相应的网页，然后我们将渲染好的网页代码上传到 GitHub 上就可以了。简单来讲，利用 Hexo，我们只需要使用 Markdown 语法写文章，剩下的事情全部交给 Hexo 去做，我们就可以看到想要的博客效果了。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>注意, 下面的所有操作最好在科学上网的环境下完成。</p><h2 id="注册一个github账号"><a href="#注册一个github账号" class="headerlink" title="注册一个github账号"></a>注册一个github账号</h2><p>前往<a href="https://github.com/">github</a>官网，注册一个账号  </p><h2 id="安装-node-js"><a href="#安装-node-js" class="headerlink" title="安装 node.js"></a>安装 node.js</h2><p>进入 <a href="https://node.js.org/">node</a> 官网下载</p><p><img src="https://cdn.jsdelivr.net/gh/fanlumaster/BlogMaps@master/blogs/pictures/20211016163651.png"></p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>进入<a href="https://git-scm.com/">git官网</a>下载</p><h1 id="开始搭建博客"><a href="#开始搭建博客" class="headerlink" title="开始搭建博客"></a>开始搭建博客</h1><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>进入github,创建一个名字为<code>username.github.com</code>存储库(username为你的用户名)</p><h2 id="配置ssh-key"><a href="#配置ssh-key" class="headerlink" title="配置ssh key"></a>配置ssh key</h2><p>打开 Git Bash，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;user.email&quot;</span> <span class="hljs-comment"># user.email 为GitHub 上注册的邮箱</span><br></code></pre></td></tr></table></figure><p>然后直接三个回车即可，默认不需要设置密码。查看是否已经有 ssh 密钥。打开用户主目录 <code>C:\Users\username\.ssh</code>。然后找到生成的 <code>.ssh</code> 的文件夹中的 <code>id_rsa.pub</code> 密钥，将内容全部复制。其中 <code>id_rsa</code> 是私钥不能泄露，<code>id_rsa.pub</code> 是公钥可以放心告诉他人。</p><p><img src="https://cdn.jsdelivr.net/gh/fanlumaster/BlogMaps@master/blogs/pictures/20211016172518.png"></p><p><code>Title</code> 为标题，任意填即可，将刚刚复制的 <code>id_rsa.pub</code> 内容粘贴进去，最后点击 <code>Add SSH key</code>。在 <code>Git Bash</code> 中检测 <code>GitHub</code> 公钥设置是否成功，输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>验证是否连接成功，若成功，结果如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/fanlumaster/BlogMaps@master/blogs/pictures/20211016172942.png"></p><h1 id="使用Hexo-博客框架"><a href="#使用Hexo-博客框架" class="headerlink" title="使用Hexo 博客框架"></a>使用Hexo 博客框架</h1><p>Hexo 官方文档：<a href="https://hexo.io/docs/">https://hexo.io/docs/</a></p><h2 id="Hexo-简介"><a href="#Hexo-简介" class="headerlink" title="Hexo 简介"></a>Hexo 简介</h2><h3 id="Hexo-是什么"><a href="#Hexo-是什么" class="headerlink" title="Hexo 是什么"></a>Hexo 是什么</h3><p><code>Hexo</code> 是一个简单、快速、强大的基于 <code>Github Pages</code> 的博客框架，支持 <code>Markdown</code> 格式，有众多优秀插件和主题。</p><h3 id="Hexo-原理"><a href="#Hexo-原理" class="headerlink" title="Hexo 原理"></a>Hexo 原理</h3><p>由于 <code>Github Pages</code> 存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以 <code>Hexo</code> 所做的就是将这些 <code>md</code> 文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到 <code>GitHub</code>。</p><h2 id="安装和初始化"><a href="#安装和初始化" class="headerlink" title="安装和初始化"></a>安装和初始化</h2><h3 id="安装与初始化"><a href="#安装与初始化" class="headerlink" title="安装与初始化"></a>安装与初始化</h3><p>在 <code>Git Bash</code> 中输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install -g hexo-cli <span class="hljs-comment"># 此命令完成对 hexo 的安装</span><br>BASH<br></code></pre></td></tr></table></figure><p>安装完成后，在电脑的某个地方新建一个文件夹（名字可以随便取）专门用于存放博客代码，比如我的是 <code>D:\Blogs</code>，由于这个文件夹将来存放博客的所有内容和素材，以及所有的博客操作都会在其中完成，所以最好不要随便放。</p><p>在新建的博客目录下打开git bash，输入如下命令  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init<br></code></pre></td></tr></table></figure><h2 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h2><p>继续在git bash输入如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br></code></pre></td></tr></table></figure><h3 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h3><p>在 <code>Git Bash</code> 输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s <span class="hljs-comment"># 开启本地预览</span><br>BASH<br></code></pre></td></tr></table></figure><p><code>hexo s</code> 是开启本地预览服务，打开浏览器访问 <code>http://localhost:4000</code> 即可看到内容，<code>Ctrl+C</code> 停止本地预览。本地预览可以实时查看博客的编辑情况，待博客写完后一起部署到 <code>GitHub</code> 上。</p><p>第一次初始化的时候 <code>hexo</code> 已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑。</p><h3 id="上传到-GitHub"><a href="#上传到-GitHub" class="headerlink" title="上传到 GitHub"></a>上传到 GitHub</h3><h4 id="配置站点配置文件"><a href="#配置站点配置文件" class="headerlink" title="配置站点配置文件"></a>配置站点配置文件</h4><p><code>hexo</code> 有 2 种 <code>_config.yml</code> 文件，一个是根目录下的全局的 <code>_config.yml</code>，一个是各个主体 <code>theme</code> 下的 <code>_config.yml</code>。将前者称为站点配置文件， 后者称为主题配置文件。</p><p>打开根目录下站点配置文件 <code>_config.yml</code>，配置有关 <code>deploy</code> 的部分：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:username/username.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">masterYAML</span><br></code></pre></td></tr></table></figure><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>在 <code>Git Bash</code> 中输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-deployer-git --save <span class="hljs-comment"># 安装部署插件</span><br>BASH<br></code></pre></td></tr></table></figure><p>如果不进行上述操作，直接使用 <code>hexo d</code> 部署到 <code>GitHub</code>，将会报错。</p><h4 id="部署到-GitHub"><a href="#部署到-GitHub" class="headerlink" title="部署到 GitHub"></a>部署到 GitHub</h4><p>在 <code>Git Bash</code> 中输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo d<br>BASH<br></code></pre></td></tr></table></figure><p>部署成功后，打开对应的网址 <code>https://www.username.github.io</code>，如果出现了和本地预览一样的效果，那么，表明部署成功。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
